<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Concise data definition language (CDDL): a notational convention to express CBOR and JSON data structures</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 525px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 15px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 25px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements notation">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 The Style of Data Structure Specification">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Groups and Composition in CDDL">
<link href="#rfc.section.2.1.1" rel="Chapter" title="2.1.1 Usage">
<link href="#rfc.section.2.1.2" rel="Chapter" title="2.1.2 Syntax">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Types">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Values">
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Choices">
<link href="#rfc.section.2.2.3" rel="Chapter" title="2.2.3 Representation Types">
<link href="#rfc.section.2.2.4" rel="Chapter" title="2.2.4 Root type">
<link href="#rfc.section.3" rel="Chapter" title="3 Syntax">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 General conventions">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Occurrence">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Predefined names for types">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Arrays">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Maps">
<link href="#rfc.section.3.5.1" rel="Chapter" title="3.5.1 Structs">
<link href="#rfc.section.3.5.2" rel="Chapter" title="3.5.2 Tables">
<link href="#rfc.section.3.5.3" rel="Chapter" title="3.5.3 Non-deterministic order">
<link href="#rfc.section.3.5.4" rel="Chapter" title="3.5.4 Cuts in Maps">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Tags">
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Unwrapping">
<link href="#rfc.section.3.8" rel="Chapter" title="3.8 Controls">
<link href="#rfc.section.3.8.1" rel="Chapter" title="3.8.1 Control operator .size">
<link href="#rfc.section.3.8.2" rel="Chapter" title="3.8.2 Control operator .bits">
<link href="#rfc.section.3.8.3" rel="Chapter" title="3.8.3 Control operator .regexp">
<link href="#rfc.section.3.8.4" rel="Chapter" title="3.8.4 Control operators .cbor and .cborseq">
<link href="#rfc.section.3.8.5" rel="Chapter" title="3.8.5 Control operators .within and .and">
<link href="#rfc.section.3.8.6" rel="Chapter" title="3.8.6 Control operators .lt, .le, .gt, .ge, .eq, .ne, and .default">
<link href="#rfc.section.3.9" rel="Chapter" title="3.9 Socket/Plug">
<link href="#rfc.section.3.10" rel="Chapter" title="3.10 Generics">
<link href="#rfc.section.3.11" rel="Chapter" title="3.11 Operator Precedence">
<link href="#rfc.section.4" rel="Chapter" title="4 Making Use of CDDL">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 As a guide to a human user">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 For automated checking of CBOR data structure">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 For data analysis tools">
<link href="#rfc.section.5" rel="Chapter" title="5 Security considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 CDDL control operator registry">
<link href="#rfc.references" rel="Chapter" title="7 References">
<link href="#rfc.references.1" rel="Chapter" title="7.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="7.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Examples">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 RFC 7071">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Examples from JSON Content Rules">
<link href="#rfc.appendix.B" rel="Chapter" title="B ABNF grammar">
<link href="#rfc.appendix.C" rel="Chapter" title="C Matching rules">
<link href="#rfc.appendix.D" rel="Chapter" title="D Standard Prelude">
<link href="#rfc.appendix.E" rel="Chapter" title="E Use with JSON">
<link href="#rfc.appendix.F" rel="Chapter" title="F The CDDL tool">
<link href="#rfc.appendix.G" rel="Chapter" title="G Extended Diagnostic Notation">
<link href="#rfc.appendix.G.1" rel="Chapter" title="G.1 White space in byte string notation">
<link href="#rfc.appendix.G.2" rel="Chapter" title="G.2 Text in byte string notation">
<link href="#rfc.appendix.G.3" rel="Chapter" title="G.3 Embedded CBOR and CBOR sequences in byte strings">
<link href="#rfc.appendix.G.4" rel="Chapter" title="G.4 Concatenated Strings">
<link href="#rfc.appendix.G.5" rel="Chapter" title="G.5 Hexadecimal, octal, and binary numbers">
<link href="#rfc.appendix.G.6" rel="Chapter" title="G.6 Comments">
<link href="#rfc.contributors" rel="Chapter">
<link href="#rfc.acknowledgements" rel="Chapter">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.13.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Birkholz, H., Vigano, C., and C. Bormann" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-cbor-cddl-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-11-07" />
  <meta name="dct.abstract" content="This document proposes a notational convention to express CBOR data structures (RFC 7049, Concise Binary Object Representation).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON." />
  <meta name="description" content="This document proposes a notational convention to express CBOR data structures (RFC 7049, Concise Binary Object Representation).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">CBOR</td>
<td class="right">H. Birkholz</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Fraunhofer SIT</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">C. Vigano</td>
</tr>
<tr>
<td class="left">Expires: May 11, 2019</td>
<td class="right">Universit&#228;t Bremen</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Bormann</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Universitaet Bremen TZI</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">November 07, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Concise data definition language (CDDL): a notational convention to express CBOR and JSON data structures<br />
  <span class="filename">draft-ietf-cbor-cddl-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document proposes a notational convention to express CBOR data structures (RFC 7049, Concise Binary Object Representation).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 11, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements notation</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">The Style of Data Structure Specification</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Groups and Composition in CDDL</a>
</li>
<ul><li>2.1.1.   <a href="#rfc.section.2.1.1">Usage</a>
</li>
<li>2.1.2.   <a href="#rfc.section.2.1.2">Syntax</a>
</li>
</ul><li>2.2.   <a href="#rfc.section.2.2">Types</a>
</li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Values</a>
</li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Choices</a>
</li>
<li>2.2.3.   <a href="#rfc.section.2.2.3">Representation Types</a>
</li>
<li>2.2.4.   <a href="#rfc.section.2.2.4">Root type</a>
</li>
</ul></ul><li>3.   <a href="#rfc.section.3">Syntax</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">General conventions</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Occurrence</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Predefined names for types</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Arrays</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">Maps</a>
</li>
<ul><li>3.5.1.   <a href="#rfc.section.3.5.1">Structs</a>
</li>
<li>3.5.2.   <a href="#rfc.section.3.5.2">Tables</a>
</li>
<li>3.5.3.   <a href="#rfc.section.3.5.3">Non-deterministic order</a>
</li>
<li>3.5.4.   <a href="#rfc.section.3.5.4">Cuts in Maps</a>
</li>
</ul><li>3.6.   <a href="#rfc.section.3.6">Tags</a>
</li>
<li>3.7.   <a href="#rfc.section.3.7">Unwrapping</a>
</li>
<li>3.8.   <a href="#rfc.section.3.8">Controls</a>
</li>
<ul><li>3.8.1.   <a href="#rfc.section.3.8.1">Control operator .size</a>
</li>
<li>3.8.2.   <a href="#rfc.section.3.8.2">Control operator .bits</a>
</li>
<li>3.8.3.   <a href="#rfc.section.3.8.3">Control operator .regexp</a>
</li>
<li>3.8.4.   <a href="#rfc.section.3.8.4">Control operators .cbor and .cborseq</a>
</li>
<li>3.8.5.   <a href="#rfc.section.3.8.5">Control operators .within and .and</a>
</li>
<li>3.8.6.   <a href="#rfc.section.3.8.6">Control operators .lt, .le, .gt, .ge, .eq, .ne, and .default</a>
</li>
</ul><li>3.9.   <a href="#rfc.section.3.9">Socket/Plug</a>
</li>
<li>3.10.   <a href="#rfc.section.3.10">Generics</a>
</li>
<li>3.11.   <a href="#rfc.section.3.11">Operator Precedence</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Making Use of CDDL</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">As a guide to a human user</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">For automated checking of CBOR data structure</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">For data analysis tools</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Security considerations</a>
</li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">CDDL control operator registry</a>
</li>
</ul><li>7.   <a href="#rfc.references">References</a>
</li>
<ul><li>7.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>7.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Examples</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">RFC 7071</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">Examples from JSON Content Rules</a>
</li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">ABNF grammar</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Matching rules</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.D">Standard Prelude</a>
</li>
<li>Appendix E.   <a href="#rfc.appendix.E">Use with JSON</a>
</li>
<li>Appendix F.   <a href="#rfc.appendix.F">The CDDL tool</a>
</li>
<li>Appendix G.   <a href="#rfc.appendix.G">Extended Diagnostic Notation</a>
</li>
<ul><li>G.1.   <a href="#rfc.appendix.G.1">White space in byte string notation</a>
</li>
<li>G.2.   <a href="#rfc.appendix.G.2">Text in byte string notation</a>
</li>
<li>G.3.   <a href="#rfc.appendix.G.3">Embedded CBOR and CBOR sequences in byte strings</a>
</li>
<li>G.4.   <a href="#rfc.appendix.G.4">Concatenated Strings</a>
</li>
<li>G.5.   <a href="#rfc.appendix.G.5">Hexadecimal, octal, and binary numbers</a>
</li>
<li>G.6.   <a href="#rfc.appendix.G.6">Comments</a>
</li>
</ul><li><a href="#rfc.contributors">Contributors</a>
</li>
<li><a href="#rfc.acknowledgements">Acknowledgements</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">In this document, a notational convention to express CBOR <a href="#RFC7049" class="xref">[RFC7049]</a> data structures is defined.</p>
<p id="rfc.section.1.p.2">The main goal for the convention is to provide a unified notation that can be used when defining protocols that use CBOR.  We term the convention &#8220;Concise data definition language&#8221;, or CDDL.</p>
<p id="rfc.section.1.p.3">The CBOR notational convention has the following goals:</p>
<p></p>

<dl>
<dt>(G1)   </dt>
<dd>Provide an unambiguous description of the overall structure of a CBOR data item.</dd>
<dt>(G2)   </dt>
<dd>Be flexible in expressing the multiple ways in which data can be represented in the CBOR data format.</dd>
<dt>(G3)   </dt>
<dd>Able to express common CBOR datatypes and structures.</dd>
<dt>(G4)   </dt>
<dd>Provide a single format that is both readable and editable for humans and processable by machine.</dd>
<dt>(G5)   </dt>
<dd>Enable automatic checking of CBOR data items for data format compliance.</dd>
<dt>(G6)   </dt>
<dd>Enable extraction of specific elements from CBOR data for further processing.</dd>
</dl>
<p id="rfc.section.1.p.5">Not an original goal per se, but a convenient side effect of the JSON generic data model being a subset of the CBOR generic data model, is the fact that CDDL can also be used for describing JSON data structures (see <a href="#sec-json" class="xref">Appendix E</a>).</p>
<p id="rfc.section.1.p.6">This document has the following structure:</p>
<p id="rfc.section.1.p.7">The syntax of CDDL is defined in <a href="#syntax" class="xref">Section 3</a>.  Examples of CDDL and related CBOR data items (&#8220;instances&#8221;, which all happen to be in JSON form) are given in <a href="#examples" class="xref">Appendix A</a>. <a href="#usage" class="xref">Section 4</a> discusses usage of CDDL. Examples are provided early in the text to better illustrate concept definitions.  A formal definition of CDDL using ABNF grammar is provided in <a href="#abnf" class="xref">Appendix B</a>.  Finally, a <em>prelude</em> of standard CDDL definitions that is automatically prepended to and thus available in every CBOR specification is listed in <a href="#prelude" class="xref">Appendix D</a>.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#requirements-notation" id="requirements-notation">Requirements notation</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP&#160;14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.2.p.1">New terms are introduced in <em>cursive</em>.  CDDL text in the running text is in <samp>typewriter</samp>.</p>
<p id="rfc.section.1.2.p.2">In this specification, the term &#8220;byte&#8221; is used in its now customary sense as a synonym for &#8220;octet&#8221;.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#the-style-of-data-structure-specification" id="the-style-of-data-structure-specification">The Style of Data Structure Specification</a>
</h1>
<p id="rfc.section.2.p.1">CDDL focuses on styles of specification that are in use in the community employing the data model as pioneered by JSON and now refined in CBOR.</p>
<p id="rfc.section.2.p.2">There are a number of more or less atomic elements of a CBOR data model, such as numbers, simple values (false, true, nil), text and byte strings; CDDL does not focus on specifying their structure.  CDDL of course also allows adding a CBOR tag to a data item.</p>
<p id="rfc.section.2.p.3">The more important components of a data structure definition language are the data types used for composition: arrays and maps in CBOR (called arrays and objects in JSON).  While these are only two representation formats, they are used to specify four loosely distinguishable styles of composition:</p>
<p></p>

<ul>
<li>A <em>vector</em>, an array of elements that are mostly of the same semantics.  The set of signatures associated with a signed data item is a typical application of a vector.</li>
<li>A <em>record</em>, an array the elements of which have different, positionally defined semantics, as detailed in the data structure definition.  A 2D point, specified as an array of an x coordinate (which comes first) and a y coordinate (coming second) is an example of a record, as is the pair of exponent (first) and mantissa (second) in a CBOR decimal fraction.</li>
<li>A <em>table</em>, a map from a domain of map keys to a domain of map values, that are mostly of the same semantics.  A set of language tags, each mapped to a text string translated to that specific language, is an example of a table.  The key domain is usually not limited to a specific set by the specification, but open for the application, e.g., in a table mapping IP addresses to MAC addresses, the specification does not attempt to foresee all possible IP addresses.  In a language such as JavaScript, a <samp>Map</samp> (as opposed to a plain <samp>Object</samp>) would often be employed to achieve the generality of the key domain.</li>
<li>A <em>struct</em>, a map from a domain of map keys as defined by the specification to a domain of map values the semantics of each of which is bound to a specific map key.  This is what many people have in mind when they think about JSON objects; CBOR adds the ability to use map keys that are not just text strings.  Structs can be used to solve similar problems as records; the use of explicit map keys facilitates optionality and extensibility.</li>
</ul>
<p id="rfc.section.2.p.5">Two important concepts provide the foundation for CDDL:</p>
<p></p>

<ol>
<li>Instead of defining all four types of composition in CDDL separately, or even defining one kind for arrays (vectors and records) and one kind for maps (tables and structs), there is only one kind of composition in CDDL: the <em>group</em> (<a href="#group" class="xref">Section 2.1</a>).</li>
<li>The other important concept is that of a <em>type</em>.  The entire CDDL specification defines a type (the one defined by its first <em>rule</em>), which formally is the set of CBOR data items that are acceptable as &#8220;instances&#8221; for this specification.  CDDL predefines a number of basic types such as <samp>uint</samp> (unsigned integer) or <samp>tstr</samp> (text string), often making use of a simple formal notation for CBOR data items.  Each value that can be expressed as a CBOR data item also is a type in its own right, e.g. <samp>1</samp>.  A type can be built as a <em>choice</em> of other types, e.g., an <samp>int</samp> is either a <samp>uint</samp> or a <samp>nint</samp> (negative integer).  Finally, a type can be built as an array or a map from a group.</li>
</ol>
<p id="rfc.section.2.p.7">The rest of this section introduces a number of basic concepts of CDDL, and section <a href="#syntax" class="xref">Section 3</a> defines additional syntax.  <a href="#matching" class="xref">Appendix C</a> gives a concise summary of the semantics of CDDL.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#group" id="group">Groups and Composition in CDDL</a>
</h1>
<p id="rfc.section.2.1.p.1">CDDL Groups are lists of group <em>entries</em>, each of which can be a name/value pair or a more complex group expression (which then in turn stands for a sequence of name/value pairs).  A CDDL group is a production in a grammar that matches certain sequences of name/value pairs but not others.  The grammar is based on the concepts of Parsing Expression Grammars <a href="#PEG" class="xref">[PEG]</a>.</p>
<p id="rfc.section.2.1.p.2">In an array context, only the value of the name/value pair is represented; the name is annotation only (and can be left off from the group specification if not needed).  In a map context, the names become the map keys (&#8220;member keys&#8221;).</p>
<p id="rfc.section.2.1.p.3">In an array context, the actual sequence of elements in the group is important, as that sequence is the information that allows associating actual array elements with entries in the group.  In a map context, the sequence of entries in a group is not relevant (but there is still a need to write down group entries in a sequence).</p>
<p id="rfc.section.2.1.p.4">An array matches a specification given as a group when the group matches a sequence of name/value pairs the value parts of which exactly match the elements of the array in order.</p>
<p id="rfc.section.2.1.p.5">A map matches a specification given as a group when the group matches a sequence of name/value pairs such that all of these name/value pairs are present in the map and the map has no name/value pair that is not covered by the group.</p>
<p id="rfc.section.2.1.p.6">A simple example of using a group directly in a map definition is:</p>
<div id="rfc.figure.1"></div>
<div id="group-in-map"></div>
<pre>
person = {
  age: int,
  name: tstr,
  employer: tstr,
}
</pre>
<p class="figure">Figure 1: Using a group directly in a map</p>
<p id="rfc.section.2.1.p.7">The three entries of the group are written between the curly braces that create the map: Here, &#8220;age&#8221;, &#8220;name&#8221;, and &#8220;employer&#8221; are the names that turn into the map key text strings, and &#8220;int&#8221; and &#8220;tstr&#8221; (text string) are the types of the map values under these keys.</p>
<p id="rfc.section.2.1.p.8">A group by itself (without creating a map around it) can be placed in (round) parentheses, and given a name by using it in a rule:</p>
<div id="rfc.figure.2"></div>
<div id="basic-group"></div>
<pre>
pii = (
  age: int,
  name: tstr,
  employer: tstr,
)
</pre>
<p class="figure">Figure 2: A basic group</p>
<p id="rfc.section.2.1.p.9">This separate, named group definition allows us to rephrase <a href="#group-in-map" class="xref">Figure 1</a> as:</p>
<div id="rfc.figure.3"></div>
<div id="group-by-name"></div>
<pre>
person = {
  pii
}
</pre>
<p class="figure">Figure 3: Using a group by name</p>
<p id="rfc.section.2.1.p.10">Note that the (curly) braces signify the creation of a map; the groups themselves are neutral as to whether they will be used in a map or an array.</p>
<p id="rfc.section.2.1.p.11">As shown in <a href="#group-in-map" class="xref">Figure 1</a>, the parentheses for groups are optional when there is some other set of brackets present.  Note that they can still be used, leading to the not so realistic, but perfectly valid example:</p>
<div id="rfc.figure.4"></div>
<div id="paren-group-in-map"></div>
<pre>
person = {(
  age: int,
  name: tstr,
  employer: tstr,
)}
</pre>
<p class="figure">Figure 4: Using a parenthesized group in a map</p>
<p id="rfc.section.2.1.p.12">Groups can be used to factor out common parts of structs, e.g., instead of writing copy/paste style specifications such as in <a href="#group_redundancy" class="xref">Figure 5</a>, one can factor out the common subgroup, choose a name for it, and write only the specific parts into the individual maps (<a href="#group_factorization" class="xref">Figure 6</a>).</p>
<div id="rfc.figure.5"></div>
<div id="group_redundancy"></div>
<pre>
person = {
  age: int,
  name: tstr,
  employer: tstr,
}

dog = {
  age: int,
  name: tstr,
  leash-length: float,
}
</pre>
<p class="figure">Figure 5: Maps with copy/paste</p>
<div id="rfc.figure.6"></div>
<div id="group_factorization"></div>
<pre>
person = {
  identity,
  employer: tstr,
}

dog = {
  identity,
  leash-length: float,
}

identity = (
  age: int,
  name: tstr,
)
</pre>
<p class="figure">Figure 6: Using a group for factorization</p>
<p id="rfc.section.2.1.p.13">Note that the lists inside the braces in the above definitions constitute (anonymous) groups, while <samp>identity</samp> is a named group.</p>
<h1 id="rfc.section.2.1.1">
<a href="#rfc.section.2.1.1">2.1.1.</a> <a href="#composition_usage" id="composition_usage">Usage</a>
</h1>
<p id="rfc.section.2.1.1.p.1">Groups are the instrument used in composing data structures with CDDL. It is a matter of style in defining those structures whether to define groups (anonymously) right in their contexts or whether to define them in a separate rule and to reference them with their respective name (possibly more than once).</p>
<p id="rfc.section.2.1.1.p.2">With this, one is allowed to define all small parts of their data structures and compose bigger protocol units with those or to have only one big protocol data unit that has all definitions ad hoc where needed.</p>
<h1 id="rfc.section.2.1.2">
<a href="#rfc.section.2.1.2">2.1.2.</a> <a href="#composition_syntax" id="composition_syntax">Syntax</a>
</h1>
<p id="rfc.section.2.1.2.p.1">The composition syntax intends to be concise and easy to read:</p>
<p></p>

<ul>
<li>The start and end of a group can be marked by &#8216;(&#8216; and &#8216;)&#8217;</li>
<li>Definitions of entries inside of a group are noted as follows: <em>keytype =&gt; valuetype,</em> (read &#8220;keytype maps to valuetype&#8221;).  The comma is actually optional (not just in the final entry), but it is considered good style to set it.  The double arrow can be replaced by a colon in the common case of directly using a text string or integer literal as a key (see <a href="#structs" class="xref">Section 3.5.1</a>; this is also the common way of naming elements of an array just for documentation, see <a href="#arrays" class="xref">Section 3.4</a>).</li>
</ul>
<p id="rfc.section.2.1.2.p.3">A basic entry consists of a <em>keytype</em> and a <em>valuetype</em>, both of which are types (<a href="#types" class="xref">Section 2.2</a>); this entry matches any name-value pair the name of which is in the keytype and the value of which is in the valuetype.</p>
<p id="rfc.section.2.1.2.p.4">A group defined as a sequence of group entries matches any sequence of name-value pairs that is composed by concatenation in order of what the entries match.</p>
<p id="rfc.section.2.1.2.p.5">A group definition can also contain choices between groups, see <a href="#choices" class="xref">Section 2.2.2</a>.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#types" id="types">Types</a>
</h1>
<h1 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#values" id="values">Values</a>
</h1>
<p id="rfc.section.2.2.1.p.1">Values such as numbers and strings can be used in place of a type.  (For instance, this is a very common thing to do for a keytype, common enough that CDDL provides additional convenience syntax for this.)</p>
<p id="rfc.section.2.2.1.p.2">The value notation is based on the C language, but does not offer all the syntactic variations (see <a href="#abnf" class="xref">Appendix B</a> for details).  The value notation for numbers inherits from C the distinction between integer values (no fractional part or exponent given &#8212; NR1 <a href="#ISO6093" class="xref">[ISO6093]</a>) and floating point values (where a fractional part and/or an exponent is present &#8212; NR2 or NR3), so the type <samp>1</samp> does not include any floating point numbers while the types <samp>1e3</samp> and <samp>1.5</samp> are both floating point numbers and do not include any integer numbers.</p>
<h1 id="rfc.section.2.2.2">
<a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#choices" id="choices">Choices</a>
</h1>
<p id="rfc.section.2.2.2.p.1">Many places that allow a type also allow a choice between types, delimited by a &#8220;/&#8221; (slash).  The entire choice construct can be put into parentheses if this is required to make the construction unambiguous (please see <a href="#abnf" class="xref">Appendix B</a> for the details).</p>
<p id="rfc.section.2.2.2.p.2">Choices of values can be used to express enumerations:</p>
<pre>
attire = "bow tie" / "necktie" / "Internet attire"
protocol = 6 / 17
</pre>
<p id="rfc.section.2.2.2.p.3">Similarly as for types, CDDL also allows choices between groups, delimited by a &#8220;//&#8221; (double slash).  Note that the &#8220;//&#8221; operators binds much more weakly than the other CDDL operators, so each line within <samp>delivery</samp> in the following example is its own alternative in the group choice:</p>
<pre>
address = { delivery }

delivery = (
street: tstr, ? number: uint, city //
po-box: uint, city //
per-pickup: true )

city = (
name: tstr, zip-code: uint
)
</pre>
<p id="rfc.section.2.2.2.p.4">A group choice matches the union of the sets of name-value pair sequences that the alternatives in the choice can.</p>
<p id="rfc.section.2.2.2.p.5">Both for type choices and for group choices, additional alternatives can be added to a rule later in separate rules by using &#8220;/=&#8221; and &#8220;//=&#8221;, respectively, instead of &#8220;=&#8221;:</p>
<pre>
attire /= "swimwear"

delivery //= (
lat: float, long: float, drone-type: tstr
)
</pre>
<p id="rfc.section.2.2.2.p.6">It is not an error if a name is first used with a &#8220;/=&#8221; or &#8220;//=&#8221; (there is no need to &#8220;create it&#8221; with &#8220;=&#8221;).</p>
<h1 id="rfc.section.2.2.2.1">
<a href="#rfc.section.2.2.2.1">2.2.2.1.</a> <a href="#ranges" id="ranges">Ranges</a>
</h1>
<p id="rfc.section.2.2.2.1.p.1">Instead of naming all the values that make up a choice, CDDL allows building a <em>range</em> out of two values that are in an ordering relationship.  A range can be inclusive of both ends given (denoted by joining two values by &#8220;..&#8221;), or include the first and exclude the second (denoted by instead using &#8220;&#8230;&#8221;).</p>
<pre>
device-address = byte
max-byte = 255
byte = 0..max-byte ; inclusive range
first-non-byte = 256
byte1 = 0...first-non-byte ; byte1 is equivalent to byte
</pre>
<p id="rfc.section.2.2.2.1.p.2">CDDL currently only allows ranges between integers (matching integer values) or between floating point values (matching floating point values).  If both are needed in a type, a type choice between the two kinds of ranges can be (clumsily) used:</p>
<pre>
int-range = 0..10 ; only integers match
float-range = 0.0..10.0 ; only floats match
BAD-range1 = 0..10.0 ; NOT DEFINED
BAD-range2 = 0.0..10 ; NOT DEFINED
numeric-range = int-range / float-range
</pre>
<p id="rfc.section.2.2.2.1.p.3">(See also the control operators .lt/.ge and .le/.gt in <a href="#fortran" class="xref">Section 3.8.6</a>.)</p>
<p id="rfc.section.2.2.2.1.p.4">Note that the dot is a valid name continuation character in CDDL, so</p>
<p></p>

<ul class="empty"><li>min..max</li></ul>
<p id="rfc.section.2.2.2.1.p.6">is not a range expression but a single name.  When using a name as the left hand side of a range operator, use spacing as in</p>
<p></p>

<ul class="empty"><li>min&#160;..&#160;max</li></ul>
<p id="rfc.section.2.2.2.1.p.8">to separate off the range operator.</p>
<h1 id="rfc.section.2.2.2.2">
<a href="#rfc.section.2.2.2.2">2.2.2.2.</a> <a href="#turning-a-group-into-a-choice" id="turning-a-group-into-a-choice">Turning a group into a choice</a>
</h1>
<p id="rfc.section.2.2.2.2.p.1">Some choices are built out of large numbers of values, often integers, each of which is best given a semantic name in the specification.  Instead of naming each of these integers and then accumulating these into a choice, CDDL allows building a choice from a group by prefixing it with a &#8220;&amp;&#8221; character:</p>
<pre>
terminal-color = &amp;basecolors
basecolors = (
  black: 0, red: 1,  green: 2,  yellow: 3,
  blue: 4,  magenta: 5,  cyan: 6,  white: 7,
)
extended-color = &amp;(
  basecolors,
  orange: 8,  pink: 9,  purple: 10,  brown: 11,
)
</pre>
<p id="rfc.section.2.2.2.2.p.2">As with the use of groups in arrays (<a href="#arrays" class="xref">Section 3.4</a>), the member names have only documentary value (in particular, they might be used by a tool when displaying integers that are taken from that choice).</p>
<h1 id="rfc.section.2.2.3">
<a href="#rfc.section.2.2.3">2.2.3.</a> <a href="#representation-types" id="representation-types">Representation Types</a>
</h1>
<p id="rfc.section.2.2.3.p.1">CDDL allows the specification of a data item type by referring to the CBOR representation (major types and additional information, Section 2 of <a href="#RFC7049" class="xref">[RFC7049]</a>).  How this is used should be evident from the prelude (<a href="#prelude" class="xref">Appendix D</a>): a hash mark (<samp>#</samp>) optionally followed by a number from 0 to 7 identifying the major type, which then can be followed by a dot and a number specifying the additional information.  This construction specifies the set of values that can be serialized in CBOR (i.e., <samp>any</samp>), by the given major type if one is given, or by the given major type with the additional information if both are given.  Where a major type of 6 (Tag) is used, the type of the tagged item can be specified by appending it in parentheses.</p>
<p id="rfc.section.2.2.3.p.2">Note that although this notation is based on the CBOR serialization, it is about a set of values at the data model level, e.g. <samp>#7.25</samp> specifies the set of values that can be represented as half-precision floats; it does not mandate that these values also do have to be serialized as half-precision floats: CDDL does not provide any language means to restrict the choice of serialization variants.  This also enables the use of CDDL with JSON, which uses a fundamentally different way of serializing (some of) the same values.</p>
<p id="rfc.section.2.2.3.p.3">It may be necessary to make use of representation types outside the prelude, e.g., a specification could start by making use of an existing tag in a more specific way, or define a new tag not defined in the prelude:</p>
<pre>
my_breakfast = #6.55799(breakfast)   ; cbor-any is too general!
breakfast = cereal / porridge
cereal = #6.998(tstr)
porridge = #6.999([liquid, solid])
liquid = milk / water
milk = 0
water = 1
solid = tstr
</pre>
<h1 id="rfc.section.2.2.4">
<a href="#rfc.section.2.2.4">2.2.4.</a> <a href="#root-type" id="root-type">Root type</a>
</h1>
<p id="rfc.section.2.2.4.p.1">There is no special syntax to identify the root of a CDDL data structure definition: that role is simply taken by the first rule defined in the file.</p>
<p id="rfc.section.2.2.4.p.2">This is motivated by the usual top-down approach for defining data structures, decomposing a big data structure unit into smaller parts; however, except for the root type, there is no need to strictly follow this sequence.</p>
<p id="rfc.section.2.2.4.p.3">(Note that there is no way to use a group as a root &#8211; it must be a type.)</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#syntax" id="syntax">Syntax</a>
</h1>
<p id="rfc.section.3.p.1">In this section, the overall syntax of CDDL is shown, alongside some examples just illustrating syntax.  (The definition will not attempt to be overly formal; refer to <a href="#abnf" class="xref">Appendix B</a> for the details.)</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#general-conventions" id="general-conventions">General conventions</a>
</h1>
<p id="rfc.section.3.1.p.1">The basic syntax is inspired by ABNF <a href="#RFC5234" class="xref">[RFC5234]</a>, with</p>
<p></p>

<ul>
<li>rules, whether they define groups or types, are defined with a name, followed by an equals sign &#8220;=&#8221; and the actual definition according to the respective syntactic rules of that definition.</li>
<li>A name can consist of any of the characters from the set {&#8216;A&#8217;, &#8230;, &#8216;Z&#8217;, &#8216;a&#8217;, &#8230;, &#8216;z&#8217;, &#8216;0&#8217;, &#8230;, &#8216;9&#8217;, &#8216;_&#8217;, &#8216;-&#8216;, &#8216;@&#8217;, &#8216;.&#8217;, &#8216;$&#8217;}, starting with an alphabetic character (including &#8216;@&#8217;, &#8216;_&#8217;, &#8216;$&#8217;) and ending in one or a digit.  <ul>
<li>Names are case sensitive.</li>
<li>It is preferred style to start a name with a lower case letter.</li>
<li>The hyphen is preferred over the underscore (except in a &#8220;bareword&#8221; (<a href="#structs" class="xref">Section 3.5.1</a>), where the semantics may actually require an underscore).</li>
<li>The period may be useful for larger specifications, to express some module structure (as in <samp>tcp.throughput</samp> vs. <samp>udp.throughput</samp>).</li>
<li>A number of names are predefined in the CDDL prelude, as listed in <a href="#prelude" class="xref">Appendix D</a>.</li>
<li>Rule names (types or groups) do not appear in the actual CBOR encoding, but names used as &#8220;barewords&#8221; in member keys do.</li>
</ul>
</li>
<li>Comments are started by a &#8216;;&#8217; (semicolon) character and finish at the end of a line (LF or CRLF).</li>
<li>outside strings, whitespace (spaces, newlines, and comments) is used to separate syntactic elements for readability (and to separate identifiers or numbers that follow each other); it is otherwise completely optional.</li>
<li>Hexadecimal numbers are preceded by &#8216;0x&#8217; (without quotes, lower case x), and are case insensitive.  Similarly, binary numbers are preceded by &#8216;0b&#8217;. </li>
<li>Text strings are enclosed by double quotation &#8216;&#8221;&#8217; characters.  They follow the conventions for strings as defined in section 7 of <a href="#RFC8259" class="xref">[RFC8259]</a>.  (ABNF users may want to note that there is no support in CDDL for the concept of case insensitivity in text strings; if necessary, regular expressions can be used (<a href="#regexp" class="xref">Section 3.8.3</a>).)</li>
<li>Byte strings are enclosed by single quotation &#8220;&#8217;&#8221; characters and may be prefixed by &#8220;h&#8221; or &#8220;b64&#8221;.  If unprefixed, the string is interpreted as with a text string, except that single quotes must be escaped and that the UTF-8 bytes resulting are marked as a byte string (major type 2).  If prefixed as &#8220;h&#8221; or &#8220;b64&#8221;, the string is interpreted as a sequence of pairs of hex digits (base16) or a base64(url) string, respectively (as with the diagnostic notation in section 6 of <a href="#RFC7049" class="xref">[RFC7049]</a>; cf. <a href="#textbin" class="xref">Appendix G.2</a>); any white space present within the string (including comments) is ignored in the prefixed case.</li>
<li>CDDL uses UTF-8 <a href="#RFC3629" class="xref">[RFC3629]</a> for its encoding.</li>
</ul>
<p id="rfc.section.3.1.p.3">Example:</p>
<pre>
; This is a comment
person = { g }

g = (
  "name": tstr,
  age: int,  ; "age" is a bareword
)
</pre>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#occurrence" id="occurrence">Occurrence</a>
</h1>
<p id="rfc.section.3.2.p.1">An optional <em>occurrence</em> indicator can be given in front of a group entry.  It is either one of the characters &#8216;?&#8217; (optional), &#8216;*&#8217; (zero or more), or &#8216;+&#8217; (one or more), or is of the form n*m, where n and m are optional unsigned integers and n is the lower limit (default 0) and m is the upper limit (default no limit) of occurrences.</p>
<p id="rfc.section.3.2.p.2">If no occurrence indicator is specified, the group entry is to occur exactly once (as if 1*1 were specified).  A group entry with an occurrence indicator matches sequences of name-value pairs that are composed by concatenating a number of sequences that the basic group entry matches, where the number needs to be allowed by the occurrence indicator.</p>
<p id="rfc.section.3.2.p.3">Note that CDDL, outside any directives/annotations that could possibly be defined, does not make any prescription as to whether arrays or maps use the definite length or indefinite length encoding.  I.e., there is no correlation between leaving the size of an array &#8220;open&#8221; in the spec and the fact that it is then interchanged with definite or indefinite length.</p>
<p id="rfc.section.3.2.p.4">Please also note that CDDL can describe flexibility that the data model of the target representation does not have.  This is rather obvious for JSON, but also is relevant for CBOR:</p>
<pre>
apartment = {
  kitchen: size,
  * bedroom: size,
}
size = float ; in m2
</pre>
<p id="rfc.section.3.2.p.5">The previous specification does not mean that CBOR is changed to allow to use the key &#8220;bedroom&#8221; more than once.  In other words, due to the restrictions imposed by the data model, the third line pretty much turns into:</p>
<pre>
  ? bedroom: size,
</pre>
<p id="rfc.section.3.2.p.6">(Occurrence indicators beyond one still are useful in maps for groups that allow a variety of keys.)</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#predefined-names-for-types" id="predefined-names-for-types">Predefined names for types</a>
</h1>
<p id="rfc.section.3.3.p.1">CDDL predefines a number of names.  This subsection summarizes these names, but please see <a href="#prelude" class="xref">Appendix D</a> for the exact definitions.</p>
<p id="rfc.section.3.3.p.2">The following keywords for primitive datatypes are defined:</p>
<p></p>

<dl>
<dt>&#8220;bool&#8221;</dt>
<dd style="margin-left: 8">Boolean value (major type 7, additional information 20 or 21).</dd>
<dt>&#8220;uint&#8221;</dt>
<dd style="margin-left: 8">An unsigned integer (major type 0).</dd>
<dt>&#8220;nint&#8221;</dt>
<dd style="margin-left: 8">A negative integer (major type 1).</dd>
<dt>&#8220;int&#8221;</dt>
<dd style="margin-left: 8">An unsigned integer or a negative integer.</dd>
<dt>&#8220;float16&#8221;</dt>
<dd style="margin-left: 8">A number representable as an IEEE 754 half-precision float (major type 7, additional information 25).</dd>
<dt>&#8220;float32&#8221;</dt>
<dd style="margin-left: 8">A number representable as an IEEE 754 single-precision float (major type 7, additional information 26).</dd>
<dt>&#8220;float64&#8221;</dt>
<dd style="margin-left: 8">A number representable as an IEEE 754 double-precision float (major type 7, additional information 27).</dd>
<dt>&#8220;float&#8221;</dt>
<dd style="margin-left: 8">One of float16, float32, or float64.</dd>
<dt>&#8220;bstr&#8221; or &#8220;bytes&#8221;</dt>
<dd style="margin-left: 8">A byte string (major type 2).</dd>
<dt>&#8220;tstr&#8221; or &#8220;text&#8221;</dt>
<dd style="margin-left: 8">Text string (major type 3)</dd>
</dl>
<p id="rfc.section.3.3.p.4">(Note that there are no predefined names for arrays or maps; these are defined with the syntax given below.)</p>
<p id="rfc.section.3.3.p.5">In addition, a number of types are defined in the prelude that are associated with CBOR tags, such as <samp>tdate</samp>, <samp>bigint</samp>, <samp>regexp</samp> etc.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#arrays" id="arrays">Arrays</a>
</h1>
<p id="rfc.section.3.4.p.1">Array definitions surround a group with square brackets.</p>
<p id="rfc.section.3.4.p.2">For each entry, an occurrence indicator as specified in <a href="#occurrence" class="xref">Section 3.2</a> is permitted.</p>
<p id="rfc.section.3.4.p.3">For example:</p>
<pre>
unlimited-people = [* person]
one-or-two-people = [1*2 person]
at-least-two-people = [2* person]
person = (
    name: tstr,
    age: uint,
)
</pre>
<p id="rfc.section.3.4.p.4">The group <samp>person</samp> is defined in such a way that repeating it in the array each time generates alternating names and ages, so these are four valid values for a data item of type <samp>unlimited-people</samp>:</p>
<pre>
["roundlet", 1047, "psychurgy", 2204, "extrarhythmical", 2231]
[]
["aluminize", 212, "climograph", 4124]
["penintime", 1513, "endocarditis", 4084, "impermeator", 1669,
 "coextension", 865]
</pre>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> <a href="#maps" id="maps">Maps</a>
</h1>
<p id="rfc.section.3.5.p.1">The syntax for specifying maps merits special attention, as well as a number of optimizations and conveniences, as it is likely to be the focal point of many specifications employing CDDL.  While the syntax does not strictly distinguish struct and table usage of maps, it caters specifically to each of them.</p>
<p id="rfc.section.3.5.p.2">But first, let&#8217;s reiterate a feature of CBOR that it has inherited from JSON: The key/value pairs in CBOR maps have no fixed ordering.  (One could imagine situations where fixing the ordering may be of use.  For example, a decoder could look for values related with integer keys 1, 3 and 7.  If the order were fixed and the decoder encounters the key 4 without having encountered key 3, it could conclude that key 3 is not available without doing more complicated bookkeeping.  Unfortunately, neither JSON nor CBOR support this, so no attempt was made to support this in CDDL either.)</p>
<h1 id="rfc.section.3.5.1">
<a href="#rfc.section.3.5.1">3.5.1.</a> <a href="#structs" id="structs">Structs</a>
</h1>
<p id="rfc.section.3.5.1.p.1">The &#8220;struct&#8221; usage of maps is similar to the way JSON objects are used in many JSON applications.</p>
<p id="rfc.section.3.5.1.p.2">A map is defined in the same way as defining an array (see <a href="#arrays" class="xref">Section 3.4</a>), except for using curly braces &#8220;{}&#8221; instead of square brackets &#8220;[]&#8221;.</p>
<p id="rfc.section.3.5.1.p.3">An occurrence indicator as specified in <a href="#occurrence" class="xref">Section 3.2</a> is permitted for each group entry.</p>
<p id="rfc.section.3.5.1.p.4">The following is an example of a structure:</p>
<pre>
Geography = [
  city           : tstr,
  gpsCoordinates : GpsCoordinates,
]

GpsCoordinates = {
  longitude      : uint,            ; multiplied by 10^7
  latitude       : uint,            ; multiplied by 10^7
}
</pre>
<p id="rfc.section.3.5.1.p.5">When encoding, the Geography structure is encoded using a CBOR array with two entries (the keys for the group entries are ignored), whereas the GpsCoordinates are encoded as a CBOR map with two key/value pairs.</p>
<p id="rfc.section.3.5.1.p.6">Types used in a structure can be defined in separate rules or just in place (potentially placed inside parentheses, such as for choices).  E.g.:</p>
<pre>
located-samples = {
  sample-point: int,
  samples: [+ float],
}

</pre>
<p id="rfc.section.3.5.1.p.7">where <samp>located-samples</samp> is the datatype to be used when referring to the struct, and <samp>sample-point</samp> and <samp>samples</samp> are the keys to be used.  This is actually a complete example: an identifier that is followed by a colon can be directly used as the text string for a member key (we speak of a &#8220;bareword&#8221; member key), as can a double-quoted string or a number.  (When other types, in particular multi-valued ones, are used as the types of keys, they are followed by a double arrow, see below.)</p>
<p id="rfc.section.3.5.1.p.8">If a text string key does not match the syntax for an identifier (or if the specifier just happens to prefer using double quotes), the text string syntax can also be used in the member key position, followed by a colon.  The above example could therefore have been written with quoted strings in the member key positions.  More generally, all the types defined can be used in a keytype position by following them with a double arrow &#8212; in particular, the double arrow is necessary if a type is named by an identifier (which would be interpreted as a string before a colon).  A string also is a (single-valued) type, so another form for this example is:</p>
<pre>
located-samples = {
  "sample-point" =&gt; int,
  "samples" =&gt; [+ float],
}
</pre>
<p id="rfc.section.3.5.1.p.9">See <a href="#cuts-in-maps" class="xref">Section 3.5.4</a> below for how the colon shortcut described here also adds some implied semantics.</p>
<p id="rfc.section.3.5.1.p.10">A better way to demonstrate the double-arrow use may be:</p>
<pre>
located-samples = {
  sample-point: int,
  samples: [+ float],
  * equipment-type =&gt; equipment-tolerances,
}
equipment-type = [name: tstr, manufacturer: tstr]
equipment-tolerances = [+ [float, float]]
</pre>
<p id="rfc.section.3.5.1.p.11">The example below defines a struct with optional entries: display name (as a text string), the name components first name and family name (as text strings), and age information (as an unsigned integer).</p>
<pre>
PersonalData = {
  ? displayName: tstr,
  NameComponents,
  ? age: uint,
}

NameComponents = (
  ? firstName: tstr,
  ? familyName: tstr,
)
</pre>
<p id="rfc.section.3.5.1.p.12">Note that the group definition for NameComponents does not generate another map; instead, all four keys are directly in the struct built by PersonalData.</p>
<p id="rfc.section.3.5.1.p.13">In this example, all key/value pairs are optional from the perspective of CDDL.  With no occurrence indicator, an entry is mandatory.</p>
<p id="rfc.section.3.5.1.p.14">If the addition of more entries not specified by the current specification is desired, one can add this possibility explicitly:</p>
<div id="rfc.figure.7"></div>
<div id="xmp-personaldata"></div>
<pre>
PersonalData = {
  ? displayName: tstr,
  NameComponents,
  ? age: uint,
  * tstr =&gt; any
}

NameComponents = (
  ? firstName: tstr,
  ? familyName: tstr,
)
</pre>
<p class="figure">Figure 7: Personal Data: Example for extensibility</p>
<p id="rfc.section.3.5.1.p.15">The cddl tool (<a href="#tool" class="xref">Appendix F</a>) generated as one acceptable instance for this specification:</p>
<pre>
{"familyName": "agust", "antiforeignism": "pretzel",
 "springbuck": "illuminatingly", "exuviae": "ephemeris",
 "kilometrage": "frogfish"}
</pre>
<p id="rfc.section.3.5.1.p.16">(See <a href="#socketplug" class="xref">Section 3.9</a> for one way to explicitly identify an extension point.)</p>
<h1 id="rfc.section.3.5.2">
<a href="#rfc.section.3.5.2">3.5.2.</a> <a href="#tables" id="tables">Tables</a>
</h1>
<p id="rfc.section.3.5.2.p.1">A table can be specified by defining a map with entries where the keytype is not single-valued, e.g.:</p>
<pre>
square-roots = {* x =&gt; y}
x = int
y = float
</pre>
<p id="rfc.section.3.5.2.p.2">Here, the key in each key/value pair has datatype x (defined as int), and the value has datatype y (defined as float).</p>
<p id="rfc.section.3.5.2.p.3">If the specification does not need to restrict one of x or y (i.e., the application is free to choose per entry), it can be replaced by the predefined name <samp>any</samp>.</p>
<p id="rfc.section.3.5.2.p.4">As another example, the following could be used as a conversion table converting from an integer or float to a string:</p>
<pre>
tostring = {* mynumber =&gt; tstr}
mynumber = int / float
</pre>
<h1 id="rfc.section.3.5.3">
<a href="#rfc.section.3.5.3">3.5.3.</a> <a href="#non-deterministic-order" id="non-deterministic-order">Non-deterministic order</a>
</h1>
<p id="rfc.section.3.5.3.p.1">While the way arrays are matched is fully determined by the Parsing Expression Grammar (PEG) algorithm, matching is more complicated for maps, as maps do not have an inherent order.  For each candidate name/value pair that the PEG algorithm would try, a matching member is picked out of the entire map.  For certain group expressions, more than one member in the map may match.  Most often, this is inconsequential, as the group expression tends to consume all matches:</p>
<pre>
labeled-values = {
  ? fritz: number,
  * label =&gt; value
}
label = text
value = number
</pre>
<p id="rfc.section.3.5.3.p.2">Here, if any member with the key <samp>fritz</samp> is present, this will be picked by the first entry of the group; all remaining text/number member will be picked by the second entry (and if anything remains unpicked, the map does not match).</p>
<p id="rfc.section.3.5.3.p.3">However, it is possible to construct group expressions where what is actually picked is indeterminate, and does matter:</p>
<pre>
do-not-do-this = {
  int =&gt; int,
  int =&gt; 6,
}
</pre>
<p id="rfc.section.3.5.3.p.4">When this expression is matched against <samp>{3: 5, 4: 6}</samp>, the first group entry might pick off the <samp>3: 5</samp>, leaving <samp>4: 6</samp> for matching the second one.  Or it might pick off <samp>4: 6</samp>, leaving nothing for the second entry.  This pathological non-determinism is caused by specifying more general before more specific, and by having a general rule that only consumes a subset of the map key/value pairs that it is able to match &#8212; both tend not to occur in real-world specifications of maps.  At the time of writing, CDDL tools cannot detect such cases automatically, and for the present version of the CDDL specification, the specification writer is simply urged to not write pathologically non-deterministic specifications.</p>
<p id="rfc.section.3.5.3.p.5">(The astute reader will be reminded of what was called &#8220;ambiguous content models&#8221; in SGML and &#8220;non-deterministic content models&#8221; in XML.  That problem is related to the one described here, but the problem here is specifically caused by the lack of order in maps, something that the XML schema languages do not have to contend with.  Note that Relax-NG&#8217;s <samp>interleave</samp> pattern handles lack of order explicitly on the specification side, while the instances in XML always have determinate order.)</p>
<h1 id="rfc.section.3.5.4">
<a href="#rfc.section.3.5.4">3.5.4.</a> <a href="#cuts-in-maps" id="cuts-in-maps">Cuts in Maps</a>
</h1>
<p id="rfc.section.3.5.4.p.1">The extensibility idiom discussed above for structs has one problem:</p>
<pre>
extensible-map-example = {
  ? "optional-key" =&gt; int,
  * tstr =&gt; any
}
</pre>
<p id="rfc.section.3.5.4.p.2">In this example, there is one optional key &#8220;optional-key&#8221;, which, when present, maps to an integer.  There is also a wild card for any future additions.</p>
<p id="rfc.section.3.5.4.p.3">Unfortunately, the data item</p>
<pre>
{ "optional-key": "nonsense" }
</pre>
<p id="rfc.section.3.5.4.p.4">does match this specification:  While the first entry of the group does not match, the second one (the wildcard) does.  This may be very well desirable (e.g., if a future extension is to be allowed to extend the type of &#8220;optional-key&#8221;), but in many cases isn&#8217;t.</p>
<p id="rfc.section.3.5.4.p.5">In anticipation of a more general potential feature called &#8220;cuts&#8221;, CDDL allows inserting a cut &#8220;^&#8221; into the definition of the map entry:</p>
<pre>
extensible-map-example = {
  ? "optional-key" ^ =&gt; int,
  * tstr =&gt; any
}
</pre>
<p id="rfc.section.3.5.4.p.6">A cut in this position means that once the member key matches the name part of an entry that carries a cut, other potential matches for the key of the member that occur in later entries in the group of the map are no longer allowed.  In other words, when a group entry would pick a key/value pair based on just a matching key, it &#8220;locks in&#8221; the pick &#8212; this rule applies independent of whether the value matches as well, so when it does not, the entire map fails to match.  In summary, the example above no longer matches the specification as modified with the cut.</p>
<p id="rfc.section.3.5.4.p.7">Since the desire for this kind of exclusive matching is so frequent, the &#8220;:&#8221; shortcut is actually defined to include the cut semantics.  So the preceding example (including the cut) can be written more simply as:</p>
<pre>
extensible-map-example = {
  ? "optional-key": int,
  * tstr =&gt; any
}
</pre>
<p id="rfc.section.3.5.4.p.8">or even shorter, using a bareword for the key:</p>
<pre>
extensible-map-example = {
  ? optional-key: int,
  * tstr =&gt; any
}
</pre>
<h1 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> <a href="#tagsec" id="tagsec">Tags</a>
</h1>
<p id="rfc.section.3.6.p.1">A type can make use of a CBOR tag (major type 6) by using the representation type notation, giving #6.nnn(type) where nnn is an unsigned integer giving the tag number and <samp>type</samp> is the type of the data item being tagged.</p>
<p id="rfc.section.3.6.p.2">For example, the following line from the CDDL prelude (<a href="#prelude" class="xref">Appendix D</a>) defines <samp>biguint</samp> as a type name for a positive bignum N:</p>
<pre>
biguint = #6.2(bstr)
</pre>
<p id="rfc.section.3.6.p.3">The tags defined by <a href="#RFC7049" class="xref">[RFC7049]</a> are included in the prelude.  Additional tags since registered need to be added to a CDDL specification as needed; e.g., a binary UUID tag could be referenced as <samp>buuid</samp> in a specification after defining</p>
<pre>
buuid = #6.37(bstr)
</pre>
<p id="rfc.section.3.6.p.4">In the following example, usage of the tag 32 for URIs is optional:</p>
<pre>
my_uri = #6.32(tstr) / tstr
</pre>
<h1 id="rfc.section.3.7">
<a href="#rfc.section.3.7">3.7.</a> <a href="#unwrapping" id="unwrapping">Unwrapping</a>
</h1>
<p id="rfc.section.3.7.p.1">The group that is used to define a map or an array can often be reused in the definition of another map or array.  Similarly, a type defined as a tag carries an internal data item that one would like to refer to.  In these cases, it is expedient to simply use the name of the map, array, or tag type as a handle for the group or type defined inside it.</p>
<p id="rfc.section.3.7.p.2">The &#8220;unwrap&#8221; operator (written by preceding a name by a tilde character &#8220;~&#8221;) can be used to strip the type defined for a name by one layer, exposing the underlying group (for maps and arrays) or type (for tags).</p>
<p id="rfc.section.3.7.p.3">For example, an application might want to define a basic and an advanced header.  Without unwrapping, this might be done as follows:</p>
<pre>
basic-header-group = (
  field1: int,
  field2: text,
)

basic-header = [ basic-header-group ]

advanced-header = [
  basic-header-group,
  field3: bytes,
  field4: number, ; as in the tagged type "time"
]
</pre>
<p id="rfc.section.3.7.p.4">Unwrapping simplifies this to:</p>
<pre>
basic-header = [
  field1: int,
  field2: text,
]

advanced-header = [
  ~basic-header,
  field3: bytes,
  field4: ~time,
]
</pre>
<p id="rfc.section.3.7.p.5">(Note that leaving out the first unwrap operator in the latter example would lead to nesting the basic-header in its own array inside the advanced-header, while, with the unwrapped basic-header, the definition of the group inside basic-header is essentially repeated inside advanced-header, leading to a single array.  This can be used for various applications often solved by inheritance in programming languages.  The effect of unwrapping can also be described as &#8220;threading in&#8221; the group or type inside the referenced type, which suggested the thread-like &#8220;~&#8221; character.)</p>
<h1 id="rfc.section.3.8">
<a href="#rfc.section.3.8">3.8.</a> <a href="#controls" id="controls">Controls</a>
</h1>
<p id="rfc.section.3.8.p.1">A <em>control</em> allows to relate a <em>target</em> type with a <em>controller</em> type via a <em>control operator</em>.</p>
<p id="rfc.section.3.8.p.2">The syntax for a control type is <samp>target .control-operator controller</samp>, where control operators are special identifiers prefixed by a dot.  (Note that <em>target</em> or <em>controller</em> might need to be parenthesized.)</p>
<p id="rfc.section.3.8.p.3">A number of control operators are defined at this point.  Further control operators may be defined by new versions of this specification or by registering them according to the procedures in <a href="#sec-controlreg" class="xref">Section 6.1</a>.</p>
<h1 id="rfc.section.3.8.1">
<a href="#rfc.section.3.8.1">3.8.1.</a> <a href="#control-operator-size" id="control-operator-size">Control operator .size</a>
</h1>
<p id="rfc.section.3.8.1.p.1">A <samp>.size</samp> control controls the size of the target in bytes by the control type.  The control is defined for text and byte strings, where it directly controls the number of bytes in the string.  It is also defined for unsigned integers (see below).  <a href="#control-size" class="xref">Figure 8</a> shows example usage for byte strings.</p>
<div id="rfc.figure.8"></div>
<div id="control-size"></div>
<pre>
full-address = [[+ label], ip4, ip6]
ip4 = bstr .size 4
ip6 = bstr .size 16
label = bstr .size (1..63)
</pre>
<p class="figure">Figure 8: Control for size in bytes</p>
<p id="rfc.section.3.8.1.p.2">When applied to an unsigned integer, the <samp>.size</samp> control restricts the range of that integer by giving a maximum number of bytes that should be needed in a computer representation of that unsigned integer.  In other words, <samp>uint .size N</samp> is equivalent to <samp>0...BYTES_N</samp>, where BYTES_N == 256**N.</p>
<div id="rfc.figure.9"></div>
<div id="control-int-size"></div>
<pre>
audio_sample = uint .size 3 ; 24-bit, equivalent to 0..16777215
</pre>
<p class="figure">Figure 9: Control for integer size in bytes</p>
<p id="rfc.section.3.8.1.p.3">Note that, as with value restrictions in CDDL, this control is not a representation constraint; a number that fits into fewer bytes can still be represented in that form, and an inefficient implementation could use a longer form (unless that is restricted by some format constraints outside of CDDL, such as the rules in Section 3.9 of <a href="#RFC7049" class="xref">[RFC7049]</a>).</p>
<h1 id="rfc.section.3.8.2">
<a href="#rfc.section.3.8.2">3.8.2.</a> <a href="#control-operator-bits" id="control-operator-bits">Control operator .bits</a>
</h1>
<p id="rfc.section.3.8.2.p.1">A <samp>.bits</samp> control on a byte string indicates that, in the target, only the bits numbered by a number in the control type are allowed to be set.  (Bits are counted the usual way, bit number <samp>n</samp> being set in <samp>str</samp> meaning that <samp>(str[n &gt;&gt; 3] &amp; (1 &lt;&lt; (n &amp; 7))) != 0</samp>.) Similarly, a <samp>.bits</samp> control on an unsigned integer <samp>i</samp> indicates that for all unsigned integers <samp>n</samp> where <samp>(i &amp; (1 &lt;&lt; n)) != 0</samp>, <samp>n</samp> must be in the control type.</p>
<div id="rfc.figure.10"></div>
<div id="control-bits"></div>
<pre>
tcpflagbytes = bstr .bits flags
flags = &amp;(
  fin: 8,
  syn: 9,
  rst: 10,
  psh: 11,
  ack: 12,
  urg: 13,
  ece: 14,
  cwr: 15,
  ns: 0,
) / (4..7) ; data offset bits

rwxbits = uint .bits rwx
rwx = &amp;(r: 2, w: 1, x: 0)
</pre>
<p class="figure">Figure 10: Control for what bits can be set</p>
<p id="rfc.section.3.8.2.p.2">The CDDL tool generates the following ten example instances for <samp>tcpflagbytes</samp>:</p>
<pre>
h'906d' h'01fc' h'8145' h'01b7' h'013d' h'409f' h'018e' h'c05f'
h'01fa' h'01fe'
</pre>
<p id="rfc.section.3.8.2.p.3">These examples do not illustrate that the above CDDL specification does not explicitly specify a size of two bytes: A valid all clear instance of flag bytes could be <samp>h''</samp> or <samp>h'00'</samp> or even <samp>h'000000'</samp> as well.</p>
<h1 id="rfc.section.3.8.3">
<a href="#rfc.section.3.8.3">3.8.3.</a> <a href="#regexp" id="regexp">Control operator .regexp</a>
</h1>
<p id="rfc.section.3.8.3.p.1">A <samp>.regexp</samp> control indicates that the text string given as a target needs to match the XSD regular expression given as a value in the control type.  XSD regular expressions are defined in Appendix F of <a href="#W3C.REC-xmlschema-2-20041028" class="xref">[W3C.REC-xmlschema-2-20041028]</a>.</p>
<div id="rfc.figure.11"></div>
<div id="control-regexp"></div>
<pre>
nai = tstr .regexp "[A-Za-z0-9]+@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)+"
</pre>
<p class="figure">Figure 11: Control with an XSD regexp</p>
<p id="rfc.section.3.8.3.p.2">An example matching this regular expression:</p>
<pre>
"N1@CH57HF.4Znqe0.dYJRN.igjf"
</pre>
<h1 id="rfc.section.3.8.3.1">
<a href="#rfc.section.3.8.3.1">3.8.3.1.</a> <a href="#usage-considerations" id="usage-considerations">Usage considerations</a>
</h1>
<p id="rfc.section.3.8.3.1.p.1">Note that XSD regular expressions do not support the usual \x or \u escapes for hexadecimal expression of bytes or unicode code points.  However, in CDDL the XSD regular expressions are contained in text strings, the literal notation for which provides \u escapes; this should suffice for most applications that use regular expressions for text strings.  (Note that this also means that there is one level of string escaping before the XSD escaping rules are applied.)</p>
<p id="rfc.section.3.8.3.1.p.2">XSD regular expressions support character class subtraction, a feature often not found in regular expression libraries; specification writers may want to use this feature sparingly.  Similar considerations apply to Unicode character classes; where these are used, the specification that employs CDDL SHOULD identify which Unicode versions are addressed.</p>
<p id="rfc.section.3.8.3.1.p.3">Other surprises for infrequent users of XSD regular expressions may include:</p>
<p></p>

<ul>
<li>No direct support for case insensitivity.  While case insensitivity has gone mostly out of fashion in protocol design, it is sometimes needed and then needs to be expressed manually as in <samp>[Cc][Aa][Ss][Ee]</samp>.</li>
<li>The support for popular character classes such as \w and \d is based on Unicode character properties, which is often not what is desired in an ASCII-based protocol and thus might lead to surprises.  (\s and \S do have their more conventional meanings, and <samp>.</samp> matches any character but the line ending characters \r or \n.)</li>
</ul>
<h1 id="rfc.section.3.8.3.2">
<a href="#rfc.section.3.8.3.2">3.8.3.2.</a> <a href="#discussion" id="discussion">Discussion</a>
</h1>
<p id="rfc.section.3.8.3.2.p.1">There are many flavors of regular expression in use in the programming community.  For instance, perl-compatible regular expressions (PCRE) are widely used and probably are more useful than XSD regular expressions.  However, there is no normative reference for PCRE that could be used in the present document.  Instead, we opt for XSD regular expressions for now.  There is precedent for that choice in the IETF, e.g., in YANG <a href="#RFC7950" class="xref">[RFC7950]</a>.</p>
<p id="rfc.section.3.8.3.2.p.2">Note that CDDL uses controls as its main extension point.  This creates the opportunity to add further regular expression formats in addition to the one referenced here if desired.  As an example, a control &#8220;.pcre&#8221; is defined in <a href="#I-D.bormann-cbor-cddl-freezer" class="xref">[I-D.bormann-cbor-cddl-freezer]</a>.</p>
<h1 id="rfc.section.3.8.4">
<a href="#rfc.section.3.8.4">3.8.4.</a> <a href="#control-operators-cbor-and-cborseq" id="control-operators-cbor-and-cborseq">Control operators .cbor and .cborseq</a>
</h1>
<p id="rfc.section.3.8.4.p.1">A <samp>.cbor</samp> control on a byte string indicates that the byte string carries a CBOR encoded data item.  Decoded, the data item matches the type given as the right-hand side argument (type1 in the following example).</p>
<p></p>

<ul class="empty"><li><samp>bytes .cbor type1</samp></li></ul>
<p id="rfc.section.3.8.4.p.3">Similarly, a <samp>.cborseq</samp> control on a byte string indicates that the byte string carries a sequence of CBOR encoded data items.  When the data items are taken as an array, the array matches the type given as the right-hand side argument (type2 in the following example).</p>
<p></p>

<ul class="empty"><li><samp>bytes .cborseq type2</samp></li></ul>
<p id="rfc.section.3.8.4.p.5">(The conversion of the encoded sequence to an array can be effected for instance by wrapping the byte string between the two bytes 0x9f and 0xff and decoding the wrapped byte string as a CBOR encoded data item.)</p>
<h1 id="rfc.section.3.8.5">
<a href="#rfc.section.3.8.5">3.8.5.</a> <a href="#control-operators-within-and-and" id="control-operators-within-and-and">Control operators .within and .and</a>
</h1>
<p id="rfc.section.3.8.5.p.1">A <samp>.and</samp> control on a type indicates that the data item matches both that left hand side type and the type given as the right hand side.  (Formally, the resulting type is the intersection of the two types given.)</p>
<p></p>

<ul class="empty"><li><samp>type1 .and type2</samp></li></ul>
<p id="rfc.section.3.8.5.p.3">A variant of the <samp>.and</samp> control is the <samp>.within</samp> control, which expresses an additional intent: the left hand side type is meant to be a subset of the right-hand-side type.</p>
<p></p>

<ul class="empty"><li><samp>type1 .within type2</samp></li></ul>
<p id="rfc.section.3.8.5.p.5">While both forms have the identical formal semantics (intersection), the intention of the <samp>.within</samp> form is that the right hand side gives guidance to the types allowed on the left hand side, which typically is a socket (<a href="#socketplug" class="xref">Section 3.9</a>):</p>
<pre>
message = $message .within message-structure
message-structure = [message_type, *message_option]
message_type = 0..255
message_option = any

$message /= [3, dough: text, topping: [* text]]
$message /= [4, noodles: text, sauce: text, parmesan: bool]
</pre>
<p id="rfc.section.3.8.5.p.6">For <samp>.within</samp>, a tool might flag an error if type1 allows data items that are not allowed by type2.  In contrast, for <samp>.and</samp>, there is no expectation that type1 already is a subset of type2.</p>
<h1 id="rfc.section.3.8.6">
<a href="#rfc.section.3.8.6">3.8.6.</a> <a href="#fortran" id="fortran">Control operators .lt, .le, .gt, .ge, .eq, .ne, and .default</a>
</h1>
<p id="rfc.section.3.8.6.p.1">The controls .lt, .le, .gt, .ge, .eq, .ne specify a constraint on the left hand side type to be a value less than, less than or equal, greater than, greater than or equal, equal, or not equal, to a value given as a (single-valued) right hand side type.  In the present specification, the first four controls (.lt, .le, .gt, .ge) are defined only for numeric types, as these have a natural ordering relationship.</p>
<pre>
speed = number .ge 0  ; unit: m/s
</pre>
<p id="rfc.section.3.8.6.p.2">.ne and .eq are defined both for numeric values and values of other types.  If one of the values is not of a numeric type, equality is determined as follows: Text strings are equal (satisfy .eq/do not satisfy .ne) if they are byte-wise identical; the same applies for byte strings.  Arrays are equal if they have the same number of elements, all of which are equal pairwise in order between the arrays.  Maps are equal if they have the same number of key/value pairs, and there is pairwise equality between the key/value pairs between the two maps.  Tagged values are equal if they both have the same tag and the values are equal.  Values of simple types match if they are the same values.  Numeric types that occur within arrays, maps, or tagged values are equal if their numeric value is equal and they are both integers or both floating point values.  All other cases are not equal (e.g., comparing a text string with a byte string).</p>
<p id="rfc.section.3.8.6.p.3">A variant of the <samp>.ne</samp> control is the <samp>.default</samp> control, which expresses an additional intent: the value specified by the right-hand-side type is intended as a default value for the left hand side type given, and the implied .ne control is there to prevent this value from being sent over the wire.  This control is only meaningful when the control type is used in an optional context; otherwise there would be no way to express the default value.</p>
<pre>
timer = {
  time: uint,
  ? displayed-step: (number .gt 0) .default 1
}
</pre>
<h1 id="rfc.section.3.9">
<a href="#rfc.section.3.9">3.9.</a> <a href="#socketplug" id="socketplug">Socket/Plug</a>
</h1>
<p id="rfc.section.3.9.p.1">Both for type choices and group choices, a mechanism is defined that facilitates starting out with empty choices and assembling them later, potentially in separate files that are concatenated to build the full specification.</p>
<p id="rfc.section.3.9.p.2">Per convention, CDDL extension points are marked with a leading dollar sign (types) or two leading dollar signs (groups).  Tools honor that convention by not raising an error if such a type or group is not defined at all; the symbol is then taken to be an empty type choice (group choice), i.e., no choice is available.</p>
<pre>
tcp-header = {seq: uint, ack: uint, * $$tcp-option}

; later, in a different file

$$tcp-option //= (
sack: [+(left: uint, right: uint)]
)

; and, maybe in another file

$$tcp-option //= (
sack-permitted: true
)
</pre>
<p id="rfc.section.3.9.p.3">Names that start with a single &#8220;$&#8221; are &#8220;type sockets&#8221;, names with a double &#8220;$$&#8221; are &#8220;group sockets&#8221;.  It is not an error if there is no definition for a socket at all; this then means there is no way to satisfy the rule (i.e., the choice is empty).</p>
<p id="rfc.section.3.9.p.4">As a convention, all definitions (plugs) for socket names must be augmentations, i.e., they must be using &#8220;/=&#8221; and &#8220;//=&#8221;, respectively.</p>
<p id="rfc.section.3.9.p.5">To pick up the example illustrated in <a href="#xmp-personaldata" class="xref">Figure 7</a>, the socket/plug mechanism could be used as shown in <a href="#xmp-personaldata-sp" class="xref">Figure 12</a>:</p>
<div id="rfc.figure.12"></div>
<div id="xmp-personaldata-sp"></div>
<pre>
PersonalData = {
  ? displayName: tstr,
  NameComponents,
  ? age: uint,
  * $$personaldata-extensions
}

NameComponents = (
  ? firstName: tstr,
  ? familyName: tstr,
)

; The above already works as is.
; But then, we can add later:

$$personaldata-extensions //= (
  favorite-salsa: tstr,
)

; and again, somewhere else:

$$personaldata-extensions //= (
  shoesize: uint,
)
</pre>
<p class="figure">Figure 12: Personal Data example: Using socket/plug extensibility</p>
<h1 id="rfc.section.3.10">
<a href="#rfc.section.3.10">3.10.</a> <a href="#generics" id="generics">Generics</a>
</h1>
<p id="rfc.section.3.10.p.1">Using angle brackets, the left hand side of a rule can add formal parameters after the name being defined, as in:</p>
<pre>
messages = message&lt;"reboot", "now"&gt; / message&lt;"sleep", 1..100&gt;
message&lt;t, v&gt; = {type: t, value: v}
</pre>
<p id="rfc.section.3.10.p.2">When using a generic rule, the formal parameters are bound to the actual arguments supplied (also using angle brackets), within the scope of the generic rule (as if there were a rule of the form parameter = argument).</p>
<p id="rfc.section.3.10.p.3">Generic rules can be used for establishing names for both types and groups.</p>
<p id="rfc.section.3.10.p.4">(There are some limitations to nesting of generics in the tool described in <a href="#tool" class="xref">Appendix F</a> at this time.)</p>
<h1 id="rfc.section.3.11">
<a href="#rfc.section.3.11">3.11.</a> <a href="#operator-precedence" id="operator-precedence">Operator Precedence</a>
</h1>
<p id="rfc.section.3.11.p.1">As with any language that has multiple syntactic features such as prefix and infix operators, CDDL has operators that bind more tightly than others.  This is becoming more complicated than, say, in ABNF, as CDDL has both types and groups, with operators that are specific to these concepts.  Type operators (such as &#8220;/&#8221; for type choice) operate on types, while group operators (such as &#8220;//&#8221; for group choice) operate on groups.  Types can simply be used in groups, but groups need to be bracketed (as arrays or maps) to become types.  So, type operators naturally bind closer than group operators.</p>
<p id="rfc.section.3.11.p.2">For instance, in</p>
<pre>
t = [group1]
group1 = (a / b // c / d)
a = 1 b = 2 c = 3 d = 4
</pre>
<p id="rfc.section.3.11.p.3">group1 is a group choice between the type choice of a and b and the type choice of c and d.  This becomes more relevant once member keys and/or occurrences are added in:</p>
<pre>
t = {group2}
group2 = (? ab: a / b // cd: c / d)
a = 1 b = 2 c = 3 d = 4
</pre>
<p id="rfc.section.3.11.p.4">is a group choice between the optional member &#8220;ab&#8221; of type a or b and the member &#8220;cd&#8221; of type c or d.  Note that the optionality is attached to the first choice (&#8220;ab&#8221;), not to the second choice.</p>
<p id="rfc.section.3.11.p.5">Similarly, in</p>
<pre>
t = [group3]
group3 = (+ a / b / c)
a = 1 b = 2 c = 3
</pre>
<p id="rfc.section.3.11.p.6">group3 is a repetition of a type choice between a, b, and c;  if just a is to be repeatable, a group choice is needed to focus the occurrence:</p>
<p id="rfc.section.3.11.p.7">(A comment has been that this could be counter-intuitive.  The specification writer is encouraged to use parentheses liberally to guide readers that are not familiar with CDDL precedence rules.)</p>
<pre>
t = [group4]
group4 = (+ a // b / c)
a = 1 b = 2 c = 3
</pre>
<p id="rfc.section.3.11.p.8">group4 is a group choice between a repeatable a and a single b or c.</p>
<p id="rfc.section.3.11.p.9">In general, as with many other languages with operator precedence rules, it is best not to rely on them, but to insert parentheses for readability:</p>
<pre>
t = [group4a]
group4a = ((+ a) // (b / c))
a = 1 b = 2 c = 3
</pre>
<p id="rfc.section.3.11.p.10">The operator precedences, in sequence of loose to tight binding, are defined in <a href="#abnf" class="xref">Appendix B</a> and summarized in <a href="#prec" class="xref">Table 1</a>.  (Arities given are 1 for unary prefix operators and 2 for binary infix operators.)</p>
<div id="rfc.table.1"></div>
<div id="prec"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Summary of operator precedences</caption>
<thead><tr>
<th class="center">Operator</th>
<th class="right">Ar</th>
<th class="left">Operates on</th>
<th class="right">Prec</th>
</tr></thead>
<tbody>
<tr>
<td class="center">=</td>
<td class="right">2</td>
<td class="left">name = type, name = group</td>
<td class="right">1</td>
</tr>
<tr>
<td class="center">/=</td>
<td class="right">2</td>
<td class="left">name /= type</td>
<td class="right">1</td>
</tr>
<tr>
<td class="center">//=</td>
<td class="right">2</td>
<td class="left">name //= group</td>
<td class="right">1</td>
</tr>
<tr>
<td class="center">//</td>
<td class="right">2</td>
<td class="left">group // group</td>
<td class="right">2</td>
</tr>
<tr>
<td class="center">,</td>
<td class="right">2</td>
<td class="left">group, group</td>
<td class="right">3</td>
</tr>
<tr>
<td class="center">*</td>
<td class="right">1</td>
<td class="left">* group</td>
<td class="right">4</td>
</tr>
<tr>
<td class="center">N*M</td>
<td class="right">1</td>
<td class="left">N*M group</td>
<td class="right">4</td>
</tr>
<tr>
<td class="center">+</td>
<td class="right">1</td>
<td class="left">+ group</td>
<td class="right">4</td>
</tr>
<tr>
<td class="center">?</td>
<td class="right">1</td>
<td class="left">? group</td>
<td class="right">4</td>
</tr>
<tr>
<td class="center">=&gt;</td>
<td class="right">2</td>
<td class="left">type =&gt; type</td>
<td class="right">5</td>
</tr>
<tr>
<td class="center">:</td>
<td class="right">2</td>
<td class="left">name: type</td>
<td class="right">5</td>
</tr>
<tr>
<td class="center">/</td>
<td class="right">2</td>
<td class="left">type / type</td>
<td class="right">6</td>
</tr>
<tr>
<td class="center">..</td>
<td class="right">2</td>
<td class="left">type..type</td>
<td class="right">7</td>
</tr>
<tr>
<td class="center">&#8230;</td>
<td class="right">2</td>
<td class="left">type&#8230;type</td>
<td class="right">7</td>
</tr>
<tr>
<td class="center">.ctrl</td>
<td class="right">2</td>
<td class="left">type .ctrl type</td>
<td class="right">7</td>
</tr>
<tr>
<td class="center">&amp;</td>
<td class="right">1</td>
<td class="left">&amp;group</td>
<td class="right">8</td>
</tr>
<tr>
<td class="center">~</td>
<td class="right">1</td>
<td class="left">~type</td>
<td class="right">8</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#usage" id="usage">Making Use of CDDL</a>
</h1>
<p id="rfc.section.4.p.1">In this section, we discuss several potential ways to employ CDDL.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#as-a-guide-to-a-human-user" id="as-a-guide-to-a-human-user">As a guide to a human user</a>
</h1>
<p id="rfc.section.4.1.p.1">CDDL can be used to efficiently define the layout of CBOR data, such that a human implementer can easily see how data is supposed to be encoded.</p>
<p id="rfc.section.4.1.p.2">Since CDDL maps parts of the CBOR data to human readable names, tools could be built that use CDDL to provide a human friendly representation of the CBOR data, and allow them to edit such data while remaining compliant to its CDDL definition.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#for-automated-checking-of-cbor-data-structure" id="for-automated-checking-of-cbor-data-structure">For automated checking of CBOR data structure</a>
</h1>
<p id="rfc.section.4.2.p.1">CDDL has been specified such that a machine can handle the CDDL definition and related CBOR data (and, thus, also JSON data).  For example, a machine could use CDDL to check whether or not CBOR data is compliant to its definition.</p>
<p id="rfc.section.4.2.p.2">The need for thoroughness of such compliance checking depends on the application.  For example, an application may decide not to check the data structure at all, and use the CDDL definition solely as a means to indicate the structure of the data to the programmer.</p>
<p id="rfc.section.4.2.p.3">On the other end, the application may also implement a checking mechanism that goes as far as checking that all mandatory map members are available.</p>
<p id="rfc.section.4.2.p.4">The matter in how far the data description must be enforced by an application is left to the designers and implementers of that application, keeping in mind related security considerations.</p>
<p id="rfc.section.4.2.p.5">In no case the intention is that a CDDL tool would be &#8220;writing code&#8221; for an implementation.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#for-data-analysis-tools" id="for-data-analysis-tools">For data analysis tools</a>
</h1>
<p id="rfc.section.4.3.p.1">In the long run, it can be expected that more and more data will be stored using the CBOR data format.</p>
<p id="rfc.section.4.3.p.2">Where there is data, there is data analysis and the need to process such data automatically.  CDDL can be used for such automated data processing, allowing tools to verify data, clean it, and extract particular parts of interest from it.</p>
<p id="rfc.section.4.3.p.3">Since CBOR is designed with constrained devices in mind, a likely use of it would be small sensors.  An interesting use would thus be automated analysis of sensor data.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#security-considerations" id="security-considerations">Security considerations</a>
</h1>
<p id="rfc.section.5.p.1">This document presents a content rules language for expressing CBOR data structures.  As such, it does not bring any security issues on itself, although specifications of protocols that use CBOR naturally need security analyses when defined.  General guidelines for writing security considerations are defined in</p>
<p id="rfc.section.5.p.2">Security Considerations Guidelines <a href="#RFC3552" class="xref">[RFC3552]</a> (BCP 72).  Specifications using CDDL to define CBOR structures in protocols need to follow those guidelines.  Additional topics that could be considered in a security considerations section for a specification that uses CDDL to define CBOR structures include the following:</p>
<p></p>

<ul>
<li>Where could the language maybe cause confusion in a way that will enable security issues?</li>
<li>Where a CDDL matcher is part of the implementation of a system, the security of the system ought not depend on the correctness of the CDDL specification or CDDL implementation without any further defenses in place.</li>
<li>Where the CDDL includes extension points, the impact of extensions on the security of the system needs to be carefully considered.</li>
</ul>
<p id="rfc.section.5.p.4">Writers of CDDL specifications are strongly encouraged to value simplicity and transparency of the specification over its elegance.  Keep it as simple as possible while still expressing the needed data model.</p>
<p id="rfc.section.5.p.5">A related observation about formal description techniques in general that is strongly recommended to be kept in mind by writers of CDDL specifications: Just because CDDL makes it easier to handle complexity in a specification, that does not make that complexity somehow less bad (except maybe on the level of the humans having to grasp the complex structure while reading the spec).</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#sec-controlreg" id="sec-controlreg">CDDL control operator registry</a>
</h1>
<p id="rfc.section.6.1.p.1">IANA is requested to create a registry for control operators <a href="#controls" class="xref">Section 3.8</a>.  The name of this registry is &#8220;CDDL Control Operators&#8221;.</p>
<p id="rfc.section.6.1.p.2">Each entry in the subregistry must include the name of the control operator (by convention given with the leading dot) and a reference to its documentation.  Names must be composed of the leading dot followed by a text string conforming to the production &#8220;id&#8221; in <a href="#abnf" class="xref">Appendix B</a>.</p>
<p id="rfc.section.6.1.p.3">Initial entries in this registry are as follows:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">name</th>
<th class="left">documentation</th>
</tr></thead>
<tbody>
<tr>
<td class="left">.size</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.bits</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.regexp</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.cbor</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.cborseq</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.within</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.and</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.lt</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.le</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.gt</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.ge</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.eq</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.ne</td>
<td class="left">[RFCthis]</td>
</tr>
<tr>
<td class="left">.default</td>
<td class="left">[RFCthis]</td>
</tr>
</tbody>
</table>
<p id="rfc.section.6.1.p.4">All other control operator names are Unassigned.</p>
<p id="rfc.section.6.1.p.5">The IANA policy for additions to this registry is &#8220;Specification Required&#8221; as defined in <a href="#RFC8126" class="xref">[RFC8126]</a> (which involves an Expert Review) for names that do not include an internal dot, and &#8220;IETF Review&#8221; for names that do include an internal dot.  The Expert is specifically instructed that other Standards Development Organizations (SDOs) may want to define control operators that are specific to their fields (e.g., based on a binary syntax already in use at the SDO); the review process should strive to facilitate such an undertaking.</p>
<h1 id="rfc.references">
<a href="#rfc.references">7.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">7.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="ISO6093">[ISO6093]</b></td>
<td class="top">
<a>ISO</a>, "<a>Information processing -- Representation of numerical values in character strings for information interchange</a>", ISO 6093, 1985.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3552">[RFC3552]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="https://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="https://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7049">[RFC7049]</b></td>
<td class="top">
<a>Bormann, C.</a> and <a>P. Hoffman</a>, "<a href="https://tools.ietf.org/html/rfc7049">Concise Binary Object Representation (CBOR)</a>", RFC 7049, DOI 10.17487/RFC7049, October 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7493">[RFC7493]</b></td>
<td class="top">
<a>Bray, T.</a>, "<a href="https://tools.ietf.org/html/rfc7493">The I-JSON Message Format</a>", RFC 7493, DOI 10.17487/RFC7493, March 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8126">[RFC8126]</b></td>
<td class="top">
<a>Cotton, M.</a>, <a>Leiba, B.</a> and <a>T. Narten</a>, "<a href="https://tools.ietf.org/html/rfc8126">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8259">[RFC8259]</b></td>
<td class="top">
<a>Bray, T.</a>, "<a href="https://tools.ietf.org/html/rfc8259">The JavaScript Object Notation (JSON) Data Interchange Format</a>", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017.</td>
</tr>
<tr>
<td class="reference"><b id="W3C.REC-xmlschema-2-20041028">[W3C.REC-xmlschema-2-20041028]</b></td>
<td class="top">
<a>Biron, P.</a> and <a>A. Malhotra</a>, "<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028">XML Schema Part 2: Datatypes Second Edition</a>", World Wide Web Consortium Recommendation REC-xmlschema-2-20041028, October 2004.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">7.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.bormann-cbor-cddl-freezer">[I-D.bormann-cbor-cddl-freezer]</b></td>
<td class="top">
<a>Bormann, C.</a>, "<a href="https://tools.ietf.org/html/draft-bormann-cbor-cddl-freezer-01">A feature freezer for the Concise Data Definition Language (CDDL)</a>", Internet-Draft draft-bormann-cbor-cddl-freezer-01, August 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-anima-grasp">[I-D.ietf-anima-grasp]</b></td>
<td class="top">
<a>Bormann, C.</a>, <a>Carpenter, B.</a> and <a>B. Liu</a>, "<a href="https://tools.ietf.org/html/draft-ietf-anima-grasp-15">A Generic Autonomic Signaling Protocol (GRASP)</a>", Internet-Draft draft-ietf-anima-grasp-15, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-core-senml">[I-D.ietf-core-senml]</b></td>
<td class="top">
<a>Jennings, C.</a>, <a>Shelby, Z.</a>, <a>Arkko, J.</a>, <a>Keranen, A.</a> and <a>C. Bormann</a>, "<a href="https://tools.ietf.org/html/draft-ietf-core-senml-16">Sensor Measurement Lists (SenML)</a>", Internet-Draft draft-ietf-core-senml-16, May 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.newton-json-content-rules">[I-D.newton-json-content-rules]</b></td>
<td class="top">
<a>Newton, A.</a> and <a>P. Cordell</a>, "<a href="https://tools.ietf.org/html/draft-newton-json-content-rules-09">A Language for Rules Describing JSON Content</a>", Internet-Draft draft-newton-json-content-rules-09, September 2017.</td>
</tr>
<tr>
<td class="reference"><b id="PEG">[PEG]</b></td>
<td class="top">
<a>Ford, B.</a>, "<a>Parsing expression grammars</a>", Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL '04, DOI 10.1145/964001.964011, 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RELAXNG">[RELAXNG]</b></td>
<td class="top">
<a>ISO/IEC</a>, "<a>Information technology &#8212; Document Schema Definition Language (DSDL) &#8212; Part 2: Regular-grammar-based validation &#8212; RELAX NG</a>", ISO/IEC 19757-2, December 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4648">[RFC4648]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, DOI 10.17487/RFC4648, October 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7071">[RFC7071]</b></td>
<td class="top">
<a>Borenstein, N.</a> and <a>M. Kucherawy</a>, "<a href="https://tools.ietf.org/html/rfc7071">A Media Type for Reputation Interchange</a>", RFC 7071, DOI 10.17487/RFC7071, November 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7950">[RFC7950]</b></td>
<td class="top">
<a>Bjorklund, M.</a>, "<a href="https://tools.ietf.org/html/rfc7950">The YANG 1.1 Data Modeling Language</a>", RFC 7950, DOI 10.17487/RFC7950, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8007">[RFC8007]</b></td>
<td class="top">
<a>Murray, R.</a> and <a>B. Niven-Jenkins</a>, "<a href="https://tools.ietf.org/html/rfc8007">Content Delivery Network Interconnection (CDNI) Control Interface / Triggers</a>", RFC 8007, DOI 10.17487/RFC8007, December 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8152">[RFC8152]</b></td>
<td class="top">
<a>Schaad, J.</a>, "<a href="https://tools.ietf.org/html/rfc8152">CBOR Object Signing and Encryption (COSE)</a>", RFC 8152, DOI 10.17487/RFC8152, July 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#examples" id="examples">Examples</a>
</h1>
<p id="rfc.section.A.p.1">This section contains a few examples of structures defined using CDDL.</p>
<p id="rfc.section.A.p.2">The theme for the first example is taken from <a href="#RFC7071" class="xref">[RFC7071]</a>, which defines certain JSON structures in English.  For a similar example, it may also be of interest to examine Appendix A of <a href="#RFC8007" class="xref">[RFC8007]</a>, which contains a CDDL definition for a JSON structure defined in the main body of the RFC.</p>
<p id="rfc.section.A.p.3">The second subsection in this appendix translates examples from <a href="#I-D.newton-json-content-rules" class="xref">[I-D.newton-json-content-rules]</a> into CDDL.</p>
<p id="rfc.section.A.p.4">These examples all happen to describe data that is interchanged in JSON.  Examples for CDDL definitions of data that is interchanged in CBOR can be found in <a href="#RFC8152" class="xref">[RFC8152]</a>, <a href="#I-D.ietf-anima-grasp" class="xref">[I-D.ietf-anima-grasp]</a>, or <a href="#I-D.ietf-core-senml" class="xref">[I-D.ietf-core-senml]</a>.</p>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#example-7071" id="example-7071">RFC 7071</a>
</h1>
<p><a href="#RFC7071" class="xref">[RFC7071]</a> defines the Reputon structure for JSON using somewhat formalized English text. Here is a (somewhat verbose) equivalent definition using the same terms, but notated in CDDL:</p>
<pre>
reputation-object = {
  reputation-context,
  reputon-list
}

reputation-context = (
  application: text
)

reputon-list = (
  reputons: reputon-array
)

reputon-array = [* reputon]

reputon = {
  rater-value,
  assertion-value,
  rated-value,
  rating-value,
  ? conf-value,
  ? normal-value,
  ? sample-value,
  ? gen-value,
  ? expire-value,
  * ext-value,
}

rater-value = ( rater: text )
assertion-value = ( assertion: text )
rated-value = ( rated: text )
rating-value = ( rating: float16 )
conf-value = ( confidence: float16 )
normal-value = ( normal-rating: float16 )
sample-value = ( sample-size: uint )
gen-value = ( generated: uint )
expire-value = ( expires: uint )
ext-value = ( text =&gt; any )
</pre>
<p id="rfc.section.A.1.p.2">An equivalent, more compact form of this example would be:</p>
<pre>
reputation-object = {
  application: text
  reputons: [* reputon]
}

reputon = {
  rater: text
  assertion: text
  rated: text
  rating: float16
  ? confidence: float16
  ? normal-rating: float16
  ? sample-size: uint
  ? generated: uint
  ? expires: uint
  * text =&gt; any
}
</pre>
<p id="rfc.section.A.1.p.3">Note how this rather clearly delineates the structure somewhat shrouded by so many words in section 6.2.2. of <a href="#RFC7071" class="xref">[RFC7071]</a>.  Also, this definition makes it clear that several ext-values are allowed (by definition with different member names); RFC 7071 could be read to forbid the repetition of ext-value (&#8220;A specific reputon-element MUST NOT appear more than once&#8221; is ambiguous.)</p>
<p id="rfc.section.A.1.p.4">The CDDL tool (which hasn&#8217;t quite been trained for polite conversation) says:</p>
<pre>
{
  "application": "tridentiferous",
  "reputons": [
    {
      "rater": "loamily",
      "assertion": "Dasyprocta",
      "rated": "uncommensurableness",
      "rating": 0.05055809746548934,
      "confidence": 0.7484706448605812,
      "normal-rating": 0.8677887734049299,
      "sample-size": 4059,
      "expires": 3969,
      "bearer": "nitty",
      "faucal": "postulnar",
      "naturalism": "sarcotic"
    },
    {
      "rater": "precreed",
      "assertion": "xanthosis",
      "rated": "balsamy",
      "rating": 0.36091333590593955,
      "confidence": 0.3700759808403371,
      "sample-size": 3904
    },
    {
      "rater": "urinosexual",
      "assertion": "malacostracous",
      "rated": "arenariae",
      "rating": 0.9210673488013762,
      "normal-rating": 0.4778762617112776,
      "sample-size": 4428,
      "generated": 3294,
      "backfurrow": "enterable",
      "fruitgrower": "flannelflower"
    },
    {
      "rater": "pedologistically",
      "assertion": "unmetaphysical",
      "rated": "elocutionist",
      "rating": 0.42073613384304287,
      "misimagine": "retinaculum",
      "snobbish": "contradict",
      "Bosporanic": "periostotomy",
      "dayworker": "intragyral"
    }
  ]
}
</pre>
<h1 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#examples-from-json-content-rules" id="examples-from-json-content-rules">Examples from JSON Content Rules</a>
</h1>
<p id="rfc.section.A.2.p.1">Although <a href="#I-D.newton-json-content-rules" class="xref">JSON Content Rules</a> seems to address a more general problem than CDDL, it is still a worthwhile resource to explore for examples (beyond all the inspiration the format itself has had for CDDL).</p>
<p id="rfc.section.A.2.p.2">Figure 2 of the JCR I-D looks very similar, if slightly less noisy, in CDDL:</p>
<div id="rfc.figure.13"></div>
<div id="jcrfig2"></div>
<pre>
root = [2*2 {
  precision: text,
  Latitude: float,
  Longitude: float,
  Address: text,
  City: text,
  State: text,
  Zip: text,
  Country: text
}]
</pre>
<p class="figure">Figure 13: JCR, Figure 2, in CDDL</p>
<p id="rfc.section.A.2.p.3">Apart from the lack of a need to quote the member names, text strings are called <samp>text</samp> or <samp>tstr</samp> in CDDL (<samp>string</samp> would be ambiguous as CBOR also provides byte strings).</p>
<p id="rfc.section.A.2.p.4">The CDDL tool creates the below example instance for this:</p>
<pre>
[{"precision": "pyrosphere", "Latitude": 0.5399712314350172,
  "Longitude": 0.5157523963028087, "Address": "resow",
  "City": "problemwise", "State": "martyrlike", "Zip": "preprove",
  "Country": "Pace"},
 {"precision": "unrigging", "Latitude": 0.10422704368372193,
  "Longitude": 0.6279808663725834, "Address": "picturedom",
  "City": "decipherability", "State": "autometry", "Zip": "pout",
  "Country": "wimple"}]
</pre>
<p id="rfc.section.A.2.p.5">Figure 4 of the JCR I-D in CDDL:</p>
<pre>
root = { image }

image = (
  Image: {
    size,
    Title: text,
    thumbnail,
    IDs: [* int]
  }
)

size = (
  Width: 0..1280
  Height: 0..1024
)

thumbnail = (
  Thumbnail: {
    size,
    Url: ~uri
  }
)
</pre>
<p id="rfc.section.A.2.p.6">This shows how the group concept can be used to keep related elements (here: width, height) together, and to emulate the JCR style of specification.  (It also shows referencing a type by unwrapping a tag from the prelude, <samp>uri</samp> &#8211; this could be done differently.)  The more compact form of Figure 5 of the JCR I-D could be emulated like this:</p>
<pre>
root = {
  Image: {
    size, Title: text,
    Thumbnail: { size, Url: ~uri },
    IDs: [* int]
  }
}

size = (
  Width: 0..1280,
  Height: 0..1024,
)
</pre>
<p id="rfc.section.A.2.p.7">The CDDL tool creates the below example instance for this:</p>
<pre>
{"Image": {"Width": 566, "Height": 516, "Title": "leisterer",
  "Thumbnail": {"Width": 1111, "Height": 176, "Url": 32("scrog")},
  "IDs": []}}
</pre>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#abnf" id="abnf">ABNF grammar</a>
</h1>
<p id="rfc.section.B.p.1">The following is a formal definition of the CDDL syntax in Augmented Backus-Naur Form (ABNF, <a href="#RFC5234" class="xref">[RFC5234]</a>).</p>
<div id="rfc.figure.14"></div>
<div id="fig-abnf"></div>
<pre>
cddl = S 1*(rule S)
rule = typename [genericparm] S assignt S type
     / groupname [genericparm] S assigng S grpent

typename = id
groupname = id

assignt = "=" / "/="
assigng = "=" / "//="

genericparm = "&lt;" S id S *("," S id S ) "&gt;"
genericarg = "&lt;" S type1 S *("," S type1 S ) "&gt;"

type = type1 *(S "/" S type1)

type1 = type2 [S (rangeop / ctlop) S type2]

type2 = value
      / typename [genericarg]
      / "(" S type S ")"
      / "{" S group S "}"
      / "[" S group S "]"
      / "~" S typename [genericarg]
      / "&amp;" S "(" S group S ")"
      / "&amp;" S groupname [genericarg]
      / "#" "6" ["." uint] "(" S type S ")" ; note no space!
      / "#" DIGIT ["." uint]                ; major/ai
      / "#"                                 ; any

rangeop = "..." / ".."

ctlop = "." id

group = grpchoice *(S "//" S grpchoice)

grpchoice = *(grpent optcom)

grpent = [occur S] [memberkey S] type
       / [occur S] groupname [genericarg]  ; preempted by above
       / [occur S] "(" S group S ")"

memberkey = type1 S ["^" S] "=&gt;"
          / bareword S ":"
          / value S ":"

bareword = id

optcom = S ["," S]

occur = [uint] "*" [uint]
      / "+"
      / "?"

uint = DIGIT1 *DIGIT
     / "0x" 1*HEXDIG
     / "0b" 1*BINDIG
     / "0"

value = number
      / text
      / bytes

int = ["-"] uint

; This is a float if it has fraction or exponent; int otherwise
number = hexfloat / (int ["." fraction] ["e" exponent ])
hexfloat = "0x" 1*HEXDIG ["." 1*HEXDIG] "p" exponent
fraction = 1*DIGIT
exponent = ["+"/"-"] 1*DIGIT

text = %x22 *SCHAR %x22
SCHAR = %x20-21 / %x23-5B / %x5D-10FFFD / SESC
SESC = "\" %x20-10FFFD

bytes = [bsqual] %x27 *BCHAR %x27
BCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF
bsqual = "h" / "b64"

id = EALPHA *(*("-" / ".") (EALPHA / DIGIT))
ALPHA = %x41-5A / %x61-7A
EALPHA = ALPHA / "@" / "_" / "$"
DIGIT = %x30-39
DIGIT1 = %x31-39
HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
BINDIG = %x30-31

S = *WS
WS = SP / NL
SP = %x20
NL = COMMENT / CRLF
COMMENT = ";" *PCHAR CRLF
PCHAR = %x20-10FFFD
CRLF = %x0A / %x0D.0A
</pre>
<p class="figure">Figure 14: CDDL ABNF</p>
<p id="rfc.section.B.p.2">Note that this ABNF does not attempt to reflect the detailed rules of what can be in a prefixed byte string.</p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#matching" id="matching">Matching rules</a>
</h1>
<p id="rfc.section.C.p.1">In this appendix, we go through the ABNF syntax rules defined in <a href="#abnf" class="xref">Appendix B</a> and briefly describe the matching semantics of each syntactic feature.  In this context, an instance (data item) &#8220;matches&#8221; a CDDL specification if it is allowed by the CDDL specification; this is then broken down to parts of specifications (type and group expressions) and parts of instances (data items).</p>
<pre>
cddl = S 1*(rule S)
</pre>
<p id="rfc.section.C.p.2">A CDDL specification is a sequence of one or more rules.  Each rule gives a name to a right hand side expression, either a CDDL type or a CDDL group.  Rule names can be used in the rule itself and/or other rules (and tools can output warnings if that is not the case).  The order of the rules is significant only in two cases:</p>
<p></p>

<ol>
<li>The first rule defines the semantics of the entire specification; hence, there is no need to give that root rule a special name or special syntax in the language (as, e.g., with &#8220;start&#8221; in Relax-NG); its name can be therefore chosen to be descriptive.  (As with all other rule names, the name of the initial rule may be used in itself or in other rules).</li>
<li>Where a rule contributes to a type or group choice (using <samp>/=</samp> or <samp>//=</samp>), that choice is populated in the order the rules are given; see below.</li>
</ol>
<pre>
rule = typename [genericparm] S assignt S type
     / groupname [genericparm] S assigng S grpent

typename = id
groupname = id
</pre>
<p id="rfc.section.C.p.4">A rule defines a name for a type expression (production <samp>type</samp>) or for a group expression (production <samp>grpent</samp>), with the intention that the semantics does not change when the name is replaced by its (parenthesized if needed) definition.  Note that whether the name defined by a rule stands for a type or a group isn&#8217;t always determined by syntax alone: e.g., <samp>a = b</samp> can make <samp>a</samp> a type if <samp>b</samp> is one, or a group if <samp>b</samp> is one.  More subtly, in <samp>a = (b)</samp>, <samp>a</samp> may be used as a type if <samp>b</samp> is a type, or as a group both when <samp>b</samp> is a group and when <samp>b</samp> is a type (a good convention to make the latter case stand out to the human reader is to write <samp>a = (b,)</samp>).  (Note that the same dual meaning of parentheses applies within an expression, but often can be resolved by the context of the parenthesized expression.  On the more general point, it may not be clear immediately either whether <samp>b</samp> stands for a group or a type &#8212; this semantic processing may need to span several levels of rule definitions before a determination can be made.)</p>
<pre>
assignt = "=" / "/="
assigng = "=" / "//="
</pre>
<p id="rfc.section.C.p.5">A plain equals sign defines the rule name as the equivalent of the expression to the right.  A <samp>/=</samp> or <samp>//=</samp> extends a named type or a group by additional choices; a number of these could be replaced by collecting all the right hand sides and creating a single rule with a type choice or a group choice built from the right hand sides in the order of the rules given.  (It is not an error to extend a rule name that has not yet been defined; this makes the right hand side the first entry in the choice being created.)</p>
<pre>
genericparm = "&lt;" S id S *("," S id S ) "&gt;"
genericarg = "&lt;" S type1 S *("," S type1 S ) "&gt;"
</pre>
<p id="rfc.section.C.p.6">Rule names can have generic parameters, which cause temporary assignments within the right hand sides to the parameter names from the arguments given when citing the rule name.</p>
<pre>
type = type1 *(S "/" S type1)
</pre>
<p id="rfc.section.C.p.7">A type can be given as a choice between one or more types.  The choice matches a data item if the data item matches any one of the types given in the choice.  The choice uses Parsing Expression Grammar <a href="#PEG" class="xref">[PEG]</a> semantics: The first choice that matches wins.  (As a result, the order of rules that contribute to a single rule name can very well matter.)</p>
<pre>
type1 = type2 [S (rangeop / ctlop) S type2]
</pre>
<p id="rfc.section.C.p.8">Two types can be combined with a range operator (which see below) or a control operator (see <a href="#controls" class="xref">Section 3.8</a>).</p>
<pre>
type2 = value
</pre>
<p id="rfc.section.C.p.9">A type can be just a single value (such as 1 or &#8220;icecream&#8221; or h&#8217;0815&#8217;), which matches only a data item with that specific value (no conversions defined),</p>
<pre>
      / typename [genericarg]
</pre>
<p id="rfc.section.C.p.10">or be defined by a rule giving a meaning to a name (possibly after supplying generic arguments as required by the generic parameters),</p>
<pre>
      / "(" S type S ")"
</pre>
<p id="rfc.section.C.p.11">or be defined in a parenthesized type expression (parentheses may be necessary to override some operator precedence), or</p>
<pre>
      / "{" S group S "}"
</pre>
<p id="rfc.section.C.p.12">a map expression, which matches a valid CBOR map the key/value pairs of which can be ordered in such a way that the resulting sequence matches the group expression, or</p>
<pre>
      / "[" S group S "]"
</pre>
<p id="rfc.section.C.p.13">an array expression, which matches a CBOR array the elements of which, when taken as values and complemented by a wildcard (matches anything) key each, match the group, or</p>
<pre>
      / "~" S typename [genericarg]
</pre>
<p id="rfc.section.C.p.14">an &#8220;unwrapped&#8221; group (see <a href="#unwrapping" class="xref">Section 3.7</a>), which matches the group inside a type defined as a map or an array by wrapping the group, or</p>
<pre>
      / "&amp;" S "(" S group S ")"
      / "&amp;" S groupname [genericarg]
</pre>
<p id="rfc.section.C.p.15">an enumeration expression, which matches any a value that is within the set of values that the values of the group given can take, or</p>
<pre>
      / "#" "6" ["." uint] "(" S type S ")" ; note no space!
</pre>
<p id="rfc.section.C.p.16">a tagged data item, tagged with the <samp>uint</samp> given and containing the type given as the tagged value, or</p>
<pre>
      / "#" DIGIT ["." uint]                ; major/ai
</pre>
<p id="rfc.section.C.p.17">a data item of a major type (given by the DIGIT), optionally constrained to the additional information given by the uint, or</p>
<pre>
      / "#"                                 ; any
</pre>
<p id="rfc.section.C.p.18">any data item.</p>
<pre>
rangeop = "..." / ".."
</pre>
<p id="rfc.section.C.p.19">A range operator can be used to join two type expressions that stand for either two integer values or two floating point values; it matches any value that is between the two values, where the first value is always included in the matching set and the second value is included for <samp>..</samp> and excluded for <samp>...</samp>.</p>
<pre>
ctlop = "." id
</pre>
<p id="rfc.section.C.p.20">A control operator ties a <em>target</em> type to a <em>controller</em> type as defined in <a href="#controls" class="xref">Section 3.8</a>.  Note that control operators are an extension point for CDDL; additional documents may want to define additional control operators.</p>
<pre>
group = grpchoice *(S "//" S grpchoice)
</pre>
<p id="rfc.section.C.p.21">A group matches any sequence of key/value pairs that matches any of the choices given (again using Parsing Expression Grammar semantics).</p>
<pre>
grpchoice = *(grpent optcom)
</pre>
<p id="rfc.section.C.p.22">Each of the component groups is given as a sequence of group entries.  For a match, the sequence of key/value pairs given needs to match the sequence of group entries in the sequence given.</p>
<pre>
grpent = [occur S] [memberkey S] type
</pre>
<p id="rfc.section.C.p.23">A group entry can be given by a value type, which needs to be matched by the value part of a single element, and optionally a memberkey type, which needs to be matched by the key part of the element, if the memberkey is given.  If the memberkey is not given, the entry can only be used for matching arrays, not for maps.  (See below how that is modified by the occurrence indicator.)</p>
<pre>
       / [occur S] groupname [genericarg]  ; preempted by above
</pre>
<p id="rfc.section.C.p.24">A group entry can be built from a named group, or</p>
<pre>
       / [occur S] "(" S group S ")"
</pre>
<p id="rfc.section.C.p.25">from a parenthesized group, again with a possible occurrence indicator.</p>
<pre>
memberkey = type1 S ["^" S] "=&gt;"
          / bareword S ":"
          / value S ":"
</pre>
<p id="rfc.section.C.p.26">Key types can be given by a type expression, a bareword (which stands for a type that just contains a string value created from this bareword), or a value (which stands for a type that just contains this value).  A key value matches its key type if the key value is a member of the key type, unless a cut preceding it in the group applies (see <a href="#cuts-in-maps" class="xref">Section 3.5.4</a> how map matching is influenced by the presence of the cuts denoted by &#8220;^&#8221; or &#8220;:&#8221; in previous entries).</p>
<pre>
bareword = id
</pre>
<p id="rfc.section.C.p.27">A bareword is an alternative way to write a type with a single text string value; it can only be used in the syntactic context given above.</p>
<pre>
optcom = S ["," S]
</pre>
<p id="rfc.section.C.p.28">(Optional commas do not influence the matching.)</p>
<pre>
occur = [uint] "*" [uint]
      / "+"
      / "?"
</pre>
<p id="rfc.section.C.p.29">An occurrence indicator modifies the group given to its right by requiring the group to match the sequence to be matched exactly for a certain number of times (see <a href="#occurrence" class="xref">Section 3.2</a>) in sequence, i.e. it acts as a (possibly infinite) group choice that contains choices with the group repeated each of the occurrences times.</p>
<p id="rfc.section.C.p.30">The rest of the ABNF describes syntax for value notation that should be familiar from programming languages, with the possible exception of h&#8217;..&#8217; and b64&#8217;..&#8217; for byte strings, as well as syntactic elements such as comments and line ends.</p>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#prelude" id="prelude">Standard Prelude</a>
</h1>
<p id="rfc.section.D.p.1">The following prelude is automatically added to each CDDL file.  (Note that technically, it is a postlude, as it does not disturb the selection of the first rule as the root of the definition.)</p>
<div id="rfc.figure.15"></div>
<div id="fig-prelude"></div>
<pre>
any = #

uint = #0
nint = #1
int = uint / nint

bstr = #2
bytes = bstr
tstr = #3
text = tstr

tdate = #6.0(tstr)
time = #6.1(number)
number = int / float
biguint = #6.2(bstr)
bignint = #6.3(bstr)
bigint = biguint / bignint
integer = int / bigint
unsigned = uint / biguint
decfrac = #6.4([e10: int, m: integer])
bigfloat = #6.5([e2: int, m: integer])
eb64url = #6.21(any)
eb64legacy = #6.22(any)
eb16 = #6.23(any)
encoded-cbor = #6.24(bstr)
uri = #6.32(tstr)
b64url = #6.33(tstr)
b64legacy = #6.34(tstr)
regexp = #6.35(tstr)
mime-message = #6.36(tstr)
cbor-any = #6.55799(any)

float16 = #7.25
float32 = #7.26
float64 = #7.27
float16-32 = float16 / float32
float32-64 = float32 / float64
float = float16-32 / float64

false = #7.20
true = #7.21
bool = false / true
nil = #7.22
null = nil
undefined = #7.23

</pre>
<p class="figure">Figure 15: CDDL Prelude</p>
<p id="rfc.section.D.p.2">Note that the prelude is deemed to be fixed.  This means, for instance, that additional tags beyond <a href="#RFC7049" class="xref">[RFC7049]</a>, as registered, need to be defined in each CDDL file that is using them.</p>
<p id="rfc.section.D.p.3">A common stumbling point is that the prelude does not define a type <samp>string</samp>.  CBOR has byte strings (<samp>bytes</samp> in the prelude) and text strings (<samp>text</samp>), so a type that is simply called <samp>string</samp> would be ambiguous.</p>
<h1 id="rfc.appendix.E">
<a href="#rfc.appendix.E">Appendix E.</a> <a href="#sec-json" id="sec-json">Use with JSON</a>
</h1>
<p id="rfc.section.E.p.1">The JSON generic data model (implicit in <a href="#RFC8259" class="xref">[RFC8259]</a>) is a subset of the generic data model of CBOR.  So one can use CDDL with JSON by limiting oneself to what can be represented in JSON.  Roughly speaking, this means leaving out byte strings, tags, and simple values other than <samp>false</samp>, <samp>true</samp>, and <samp>null</samp>, leading to the following limited prelude:</p>
<div id="rfc.figure.16"></div>
<div id="fig-json-prelude"></div>
<pre>
any = #

uint = #0
nint = #1
int = uint / nint

tstr = #3
text = tstr

number = int / float

float16 = #7.25
float32 = #7.26
float64 = #7.27
float16-32 = float16 / float32
float32-64 = float32 / float64
float = float16-32 / float64

false = #7.20
true = #7.21
bool = false / true
nil = #7.22
null = nil

</pre>
<p class="figure">Figure 16: JSON compatible subset of CDDL Prelude</p>
<p id="rfc.section.E.p.2">(The major types given here do not have a direct meaning in JSON, but they can be interpreted as CBOR major types translated through Section 4 of <a href="#RFC7049" class="xref">[RFC7049]</a>.)</p>
<p id="rfc.section.E.p.3">There are a few fine points in using CDDL with JSON.  First, JSON does not distinguish between integers and floating point numbers; there is only one kind of number (which may happen to be integral).  In this context, specifying a type as <samp>uint</samp>, <samp>nint</samp> or <samp>int</samp> then becomes a predicate that the number be integral.  As an example, this means that the following JSON numbers are all matching <samp>uint</samp>:</p>
<pre>
10 10.0 1e1 1.0e1 100e-1
</pre>
<p id="rfc.section.E.p.4">(The fact that these are all integers may be surprising to users accustomed to the long tradition in programming languages of using decimal points or exponents in a number to indicate a floating point literal.)</p>
<p id="rfc.section.E.p.5">CDDL distinguishes the various CBOR number types, but there is only one number type in JSON.  The effect of specifying a floating point precision (float16/float32/float64) is only to restrict the set of permissible values to those expressible with binary16/binary32/binary64; this is unlikely to be very useful when using CDDL for specifying JSON data structures.</p>
<p id="rfc.section.E.p.6">Fundamentally, the number system of JSON itself is based on decimal numbers and decimal fractions and does not have limits to its precision or range.  In practice, JSON numbers are often parsed into a number type that is called float64 here, creating a number of limitations to the generic data model <a href="#RFC7493" class="xref">[RFC7493]</a>.  In particular, this means that integers can only be expressed with interoperable exactness when they lie in the range [-(2**53)+1, (2**53)-1] &#8212; a smaller range than that covered by CDDL <samp>int</samp>.</p>
<p id="rfc.section.E.p.7">JSON applications that want to stay compatible with I-JSON (<a href="#RFC7493" class="xref">[RFC7493]</a>, &#8220;Internet JSON&#8221;) therefore may want to define integer types with more limited ranges, such as in <a href="#fig-json-types" class="xref">Figure 17</a>.  Note that the types given here are not part of the prelude; they need to be copied into the CDDL specification if needed.</p>
<div id="rfc.figure.17"></div>
<div id="fig-json-types"></div>
<pre>
ij-uint = 0..9007199254740991
ij-nint = -9007199254740991..-1
ij-int = -9007199254740991..9007199254740991
</pre>
<p class="figure">Figure 17: I-JSON types for CDDL (not part of prelude)</p>
<p id="rfc.section.E.p.8">JSON applications that do not need to stay compatible with I-JSON and that actually may need to go beyond the 64-bit unsigned and negative integers supported by <samp>int</samp> (= <samp>uint</samp>/<samp>nint</samp>) may want to use the following additional types from the standard prelude, which are expressed in terms of tags but can straightforwardly be mapped into JSON (but not I-JSON) numbers:</p>
<pre>
biguint = #6.2(bstr)
bignint = #6.3(bstr)
bigint = biguint / bignint
integer = int / bigint
unsigned = uint / biguint
</pre>
<p id="rfc.section.E.p.9">CDDL at this point does not have a way to express the unlimited floating point precision that is theoretically possible with JSON; at the time of writing, this is rarely used in protocols in practice.</p>
<p id="rfc.section.E.p.10">Note that a data model described in CDDL is always restricted by what can be expressed in the serialization; e.g., floating point values such as NaN (not a number) and the infinities cannot be represented in JSON even if they are allowed in the CDDL generic data model.</p>
<h1 id="rfc.appendix.F">
<a href="#rfc.appendix.F">Appendix F.</a> <a href="#tool" id="tool">The CDDL tool</a>
</h1>
<p id="rfc.section.F.p.1">A rough CDDL tool is available.  For CDDL specifications, it can check the syntax, generate one or more instances (expressed in CBOR diagnostic notation or in pretty-printed JSON), and validate an existing instance against the specification:</p>
<div id="rfc.figure.18"></div>
<div id="tool-usage"></div>
<pre>
Usage:
cddl spec.cddl generate [n]
cddl spec.cddl json-generate [n]
cddl spec.cddl validate instance.cbor
cddl spec.cddl validate instance.json
</pre>
<p class="figure">Figure 18: CDDL tool usage</p>
<p id="rfc.section.F.p.2">Install on a system with a modern Ruby via:</p>
<div id="rfc.figure.19"></div>
<div id="tool-install"></div>
<pre>
gem install cddl
</pre>
<p class="figure">Figure 19: CDDL tool installation</p>
<p id="rfc.section.F.p.3">The accompanying CBOR diagnostic tools (which are automatically installed by the above) are described in <a href="https://github.com/cabo/cbor-diag">https://github.com/cabo/cbor-diag</a>; they can be used to convert between binary CBOR, a pretty-printed form of that, CBOR diagnostic notation, JSON, and YAML.</p>
<h1 id="rfc.appendix.G">
<a href="#rfc.appendix.G">Appendix G.</a> <a href="#extended-diagnostic-notation" id="extended-diagnostic-notation">Extended Diagnostic Notation</a>
</h1>
<p id="rfc.section.G.p.1">Section 6 of <a href="#RFC7049" class="xref">[RFC7049]</a> defines a &#8220;diagnostic notation&#8221; in order to be able to converse about CBOR data items without having to resort to binary data.  Diagnostic notation is based on JSON, with extensions for representing CBOR constructs such as binary data and tags.</p>
<p id="rfc.section.G.p.2">(Standardizing this together with the actual interchange format does not serve to create another interchange format, but enables the use of a shared diagnostic notation in tools for and documents about CBOR.)</p>
<p id="rfc.section.G.p.3">This section discusses a few extensions to the diagnostic notation that have turned out to be useful since RFC 7049 was written.  We refer to the result as extended diagnostic notation (EDN).</p>
<h1 id="rfc.appendix.G.1">
<a href="#rfc.appendix.G.1">G.1.</a> <a href="#white-space-in-byte-string-notation" id="white-space-in-byte-string-notation">White space in byte string notation</a>
</h1>
<p id="rfc.section.G.1.p.1">Examples often benefit from some white space (spaces, line breaks) in byte strings.  In extended diagnostic notation, white space is ignored in prefixed byte strings; for instance, the following are equivalent:</p>
<pre>
  h'48656c6c6f20776f726c64'
  h'48 65 6c 6c 6f 20 77 6f 72 6c 64'
  h'4 86 56c 6c6f
    20776 f726c64'
</pre>
<h1 id="rfc.appendix.G.2">
<a href="#rfc.appendix.G.2">G.2.</a> <a href="#textbin" id="textbin">Text in byte string notation</a>
</h1>
<p id="rfc.section.G.2.p.1">Diagnostic notation notates Byte strings in one of the <a href="#RFC4648" class="xref">[RFC4648]</a> base encodings,, enclosed in single quotes, prefixed by &gt;h&lt; for base16, &gt;b32&lt; for base32, &gt;h32&lt; for base32hex, &gt;b64&lt; for base64 or base64url.  Quite often, byte strings carry bytes that are meaningfully interpreted as UTF-8 text.  Extended Diagnostic Notation allows the use of single quotes without a prefix to express byte strings with UTF-8 text; for instance, the following are equivalent:</p>
<pre>
'hello world'
h'68656c6c6f20776f726c64'
</pre>
<p id="rfc.section.G.2.p.2">The escaping rules of JSON strings are applied equivalently for text-based byte strings, e.g., \ stands for a single backslash and ' stands for a single quote.  White space is included literally, i.e., the previous section does not apply to text-based byte strings.</p>
<h1 id="rfc.appendix.G.3">
<a href="#rfc.appendix.G.3">G.3.</a> <a href="#embedded-cbor-and-cbor-sequences-in-byte-strings" id="embedded-cbor-and-cbor-sequences-in-byte-strings">Embedded CBOR and CBOR sequences in byte strings</a>
</h1>
<p id="rfc.section.G.3.p.1">Where a byte string is to carry an embedded CBOR-encoded item, or more generally a sequence of zero or more such items, the diagnostic notation for these zero or more CBOR data items, separated by commata, can be enclosed in &#171;&#160;and&#160;&#187; to notate the byte string resulting from encoding the data items and concatenating the result.  For instance, each pair of columns in the following are equivalent:</p>
<pre>
&lt;&lt;1&gt;&gt;              h'01'
&lt;&lt;1, 2&gt;&gt;           h'0102'
&lt;&lt;"foo", null&gt;&gt;    h'63666F6FF6'
&lt;&lt;&gt;&gt;               h''
</pre>
<h1 id="rfc.appendix.G.4">
<a href="#rfc.appendix.G.4">G.4.</a> <a href="#concatenated-strings" id="concatenated-strings">Concatenated Strings</a>
</h1>
<p id="rfc.section.G.4.p.1">While the ability to include white space enables line-breaking of encoded byte strings, a mechanism is needed to be able to include text strings as well as byte strings in direct UTF-8 representation into line-based documents (such as RFCs and source code).</p>
<p id="rfc.section.G.4.p.2">We extend the diagnostic notation by allowing multiple text strings or multiple byte strings to be notated separated by white space, these are then concatenated into a single text or byte string, respectively.  Text strings and byte strings do not mix within such a concatenation, except that byte string notation can be used inside a sequence of concatenated text string notation to encode characters that may be better represented in an encoded way.  The following four values are equivalent:</p>
<pre>
"Hello world"
"Hello " "world"
"Hello" h'20' "world"
"" h'48656c6c6f20776f726c64' ""
</pre>
<p id="rfc.section.G.4.p.3">Similarly, the following byte string values are equivalent</p>
<pre>
'Hello world'
'Hello ' 'world'
'Hello ' h'776f726c64'
'Hello' h'20' 'world'
'' h'48656c6c6f20776f726c64' '' b64''
h'4 86 56c 6c6f' h' 20776 f726c64'
</pre>
<p id="rfc.section.G.4.p.4">(Note that the approach of separating by whitespace, while familiar from the C language, requires some attention &#8211; a single comma makes a big difference here.)</p>
<h1 id="rfc.appendix.G.5">
<a href="#rfc.appendix.G.5">G.5.</a> <a href="#hexadecimal-octal-and-binary-numbers" id="hexadecimal-octal-and-binary-numbers">Hexadecimal, octal, and binary numbers</a>
</h1>
<p id="rfc.section.G.5.p.1">In addition to JSON&#8217;s decimal numbers, EDN provides hexadecimal, octal and binary numbers in the usual C-language notation (octal with 0o prefix present only).</p>
<p id="rfc.section.G.5.p.2">The following are equivalent:</p>
<pre>
4711
0x1267
0o11147
0b1001001100111
</pre>
<p id="rfc.section.G.5.p.3">As are:</p>
<pre>
1.5
0x1.8p0
0x18p-4
</pre>
<h1 id="rfc.appendix.G.6">
<a href="#rfc.appendix.G.6">G.6.</a> <a href="#comments" id="comments">Comments</a>
</h1>
<p id="rfc.section.G.6.p.1">Longer pieces of diagnostic notation may benefit from comments.  JSON famously does not provide for comments, and basic RFC 7049 diagnostic notation inherits this property.</p>
<p id="rfc.section.G.6.p.2">In extended diagnostic notation, comments can be included, delimited by slashes (&#8220;/&#8221;).  Any text within and including a pair of slashes is considered a comment.</p>
<p id="rfc.section.G.6.p.3">Comments are considered white space.  Hence, they are allowed in prefixed byte strings; for instance, the following are equivalent:</p>
<pre>
h'68656c6c6f20776f726c64'
h'68 65 6c /doubled l!/ 6c 6f /hello/
  20 /space/
  77 6f 72 6c 64' /world/
</pre>
<p id="rfc.section.G.6.p.4">This can be used to annotate a CBOR structure as in:</p>
<pre>
/grasp-message/ [/M_DISCOVERY/ 1, /session-id/ 10584416,
                 /objective/ [/objective-name/ "opsonize",
                              /D, N, S/ 7, /loop-count/ 105]]
</pre>
<p id="rfc.section.G.6.p.5">(There are currently no end-of-line comments.  If we want to add them, &#8220;//&#8221; sounds like a reasonable delimiter given that we already use slashes for comments, but we also could go e.g. for &#8220;#&#8221;.)</p>
<h1 id="rfc.contributors"><a href="#rfc.contributors">Contributors</a></h1>
<p id="rfc.section.H.p.1">CDDL was originally conceived by Bert Greevenbosch, who also wrote the original five versions of this document.</p>
<h1 id="rfc.acknowledgements"><a href="#rfc.acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.I.p.1">Inspiration was taken from the C and Pascal languages, MPEG&#8217;s conventions for describing structures in the ISO base media file format, Relax-NG and its compact syntax <a href="#RELAXNG" class="xref">[RELAXNG]</a>, and in particular from Andrew Lee Newton&#8217;s <a href="#I-D.newton-json-content-rules" class="xref">&#8220;JSON Content Rules&#8221;</a>.</p>
<p id="rfc.section.I.p.2">Lots of highly useful feedback came from members of the IETF CBOR WG, in particular Ari Ker&#228;nen, Brian Carpenter, Burt Harris, Jeffrey Yasskin, Jim Hague, Jim Schaad, Joe Hildebrand, Max Pritikin, Michael Richardson, Pete Cordell, Sean Leonard, and Yaron Sheffer.  Also, Francesca Palombini and Joe volunteered to chair the WG when it was created, providing the framework for generating and processing this feedback; with Barry Leiba having taken over from Joe since.  Chris Lonvick and Ines Robles provided additional reviews during IESG processing, and Alexey Melnikov steered the process as the responsible area director.</p>
<p id="rfc.section.I.p.3">The CDDL tool reported on in <a href="#tool" class="xref">Appendix F</a> was written by Carsten Bormann, building on previous work by Troy Heninger and Tom Lord.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Henk Birkholz</span> 
	  <span class="n hidden">
		<span class="family-name">Birkholz</span>
	  </span>
	</span>
	<span class="org vcardline">Fraunhofer SIT</span>
	<span class="adr">
	  <span class="vcardline">Rheinstrasse 75</span>

	  <span class="vcardline">
		<span class="locality">Darmstadt</span>,  
		<span class="region"></span>
		<span class="code">64295</span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:henk.birkholz@sit.fraunhofer.de">henk.birkholz@sit.fraunhofer.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christoph Vigano</span> 
	  <span class="n hidden">
		<span class="family-name">Vigano</span>
	  </span>
	</span>
	<span class="org vcardline">Universit&#228;t Bremen</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:christoph.vigano@uni-bremen.de">christoph.vigano@uni-bremen.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Carsten Bormann</span> 
	  <span class="n hidden">
		<span class="family-name">Bormann</span>
	  </span>
	</span>
	<span class="org vcardline">Universitaet Bremen TZI</span>
	<span class="adr">
	  <span class="vcardline">Bibliothekstr. 1</span>

	  <span class="vcardline">
		<span class="locality">Bremen</span>,  
		<span class="region"></span>
		<span class="code">D-28359</span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">Phone: +49-421-218-63921</span>

<span class="vcardline">EMail: <a href="mailto:cabo@tzi.org">cabo@tzi.org</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/cbor-wg/cddl">Fork me on GitHub</a></div></div>
</body>
</html>
